<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DH Key Exchange - Secure Password Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
        }

        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .section {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #fafafa;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-content {
            display: grid;
            gap: 15px;
        }

        .form-group {
            display: grid;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        input[type="number"],
        input[type="text"],
        select,
        textarea {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus,
        input[type="text"]:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .range-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .keypair-list {
            display: grid;
            gap: 10px;
        }

        .keypair-item {
            padding: 12px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .keypair-item.active {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .keypair-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .keypair-id {
            font-weight: bold;
            color: #667eea;
        }

        .keypair-curve {
            font-size: 0.85em;
            color: #666;
        }

        .token-display {
            padding: 15px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 6px;
            word-break: break-all;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            max-height: 150px;
            overflow-y: auto;
            position: relative;
        }

        .copy-button {
            padding: 6px 12px;
            font-size: 0.85em;
            background: #28a745;
        }

        .copy-button:hover {
            background: #218838;
        }

        .result-box {
            padding: 20px;
            background: #e8f5e9;
            border: 2px solid #4caf50;
            border-radius: 8px;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .result-box h3 {
            color: #2e7d32;
            margin-bottom: 15px;
        }

        .result-item {
            margin-bottom: 0;
        }

        .result-item label {
            display: block;
            margin-bottom: 5px;
            color: #2e7d32;
        }

        .result-value {
            padding: 12px;
            background: white;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            font-weight: bold;
            word-break: break-all;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .verification-token {
            font-size: 1.5em;
            color: #667eea;
            text-align: center;
        }

        .alert {
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .alert-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .hidden {
            display: none;
        }

        textarea {
            min-height: 100px;
            font-family: 'Courier New', monospace;
            resize: vertical;
        }

        .link-display {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .link-display input {
            flex: 1;
        }

        .help-button {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #667eea;
            color: white;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-y: auto;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 700px;
            width: 100%;
            max-height: 90vh;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5em;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .modal-body {
            padding: 30px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .modal-body h3 {
            color: #667eea;
            margin-top: 25px;
            margin-bottom: 12px;
            font-size: 1.2em;
        }

        .modal-body h3:first-child {
            margin-top: 0;
        }

        .modal-body p {
            line-height: 1.6;
            color: #555;
            margin-bottom: 15px;
        }

        .modal-body ol, .modal-body ul {
            margin-left: 20px;
            margin-bottom: 15px;
            color: #555;
        }

        .modal-body li {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .modal-body strong {
            color: #333;
        }

        .welcome-banner {
            background: linear-gradient(135deg, #667eea15, #764ba215);
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .welcome-banner-icon {
            font-size: 2em;
        }

        .welcome-banner-text {
            flex: 1;
        }

        .welcome-banner-text p {
            margin: 0;
            color: #333;
        }

        .welcome-banner-close {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 1.5em;
            padding: 0;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .welcome-banner-close:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        @media (max-width: 768px) {
            .range-inputs {
                grid-template-columns: 1fr;
            }
            
            .section > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
            }

            .help-button {
                top: 10px;
                right: 10px;
                width: 45px;
                height: 45px;
                font-size: 1.3em;
            }

            .modal-body {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Help Button -->
    <button class="help-button" onclick="openHelpModal()" title="Help">üõü</button>

    <!-- Help Modal -->
    <div id="helpModal" class="modal-overlay" onclick="closeHelpModalOnOverlay(event)">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üõü Help & Information</h2>
                <button class="modal-close" onclick="closeHelpModal()">&times;</button>
            </div>
            <div class="modal-body">
                <h3>üìã Workflow</h3>
                <ol>
                    <li><strong><span title="User A">üë®üèΩ</span></strong> opens this page and configures password constraints (length, character types, excluded characters)</li>
                    <li><strong><span title="User A">üë®üèΩ</span></strong> generates an EC keypair and shares their token with <strong><span title="User B">üë©üèª</span></strong> (via any channel: email, chat, etc.)</li>
                    <li><strong><span title="User B">üë©üèª</span></strong> opens this page, pastes <strong><span title="User A">üë®üèΩ</span></strong>'s token, which automatically imports the constraints</li>
                    <li><strong><span title="User B">üë©üèª</span></strong> generates their own keypair and shares their token back to <strong><span title="User A">üë®üèΩ</span></strong></li>
                    <li><strong><span title="Both users">üë®üèΩüë©üèª</span></strong> now have matching shared passwords and verification tokens</li>
                    <li><strong>Verify out-of-band</strong>: <span title="Both users">üë®üèΩüë©üèª</span> compare the 6-character verification token (phone call, video chat, etc.)</li>
                    <li><strong>Use the password</strong>: Once verified, both users can use the shared password with confidence</li>
                </ol>

                <h3>üîí Security Principles</h3>
                <p>This tool uses <strong>Elliptic Curve Diffie-Hellman (ECDH)</strong> key exchange:</p>
                <ul>
                    <li><strong>Public Key Cryptography</strong>: Each user generates a keypair (private + public key). Only public keys are exchanged</li>
                    <li><strong>Shared Secret Derivation</strong>: Using ECDH, both parties independently compute the same shared secret without ever transmitting it</li>
                    <li><strong>Password Generation</strong>: The shared secret is deterministically converted to a password using the agreed constraints</li>
                    <li><strong>Verification Token</strong>: A 24-bit token (XOR of public keys) provides out-of-band verification to prevent MITM attacks</li>
                    <li><strong>Web Crypto API</strong>: All cryptography uses browser-native, audited implementations (P-256, P-384, or P-521 curves)</li>
                </ul>

                <h3>üè† Privacy & Local Operation</h3>
                <p><strong>Your data never leaves your device:</strong></p>
                <ul>
                    <li>‚úÖ <strong>100% Client-Side</strong>: All cryptographic operations happen in your browser using JavaScript</li>
                    <li>‚úÖ <strong>No Server Communication</strong>: This page makes zero network requests after loading</li>
                    <li>‚úÖ <strong>No Tracking or Analytics</strong>: No cookies, no tracking pixels, no telemetry of any kind</li>
                    <li>‚úÖ <strong>Session Storage Only</strong>: Keypairs are stored in your browser's session storage (cleared when tab closes)</li>
                    <li>‚úÖ <strong>Open Source</strong>: Single HTML file - view source to audit the complete code</li>
                </ul>
                <p><em>You control token distribution. This tool only provides the cryptographic mechanism to generate matching passwords.</em></p>

                <h3>üí° Tips</h3>
                <ul>
                    <li>Always verify the verification token out-of-band (phone, video) before using the password</li>
                    <li>Tokens can be shared via any medium (email, chat, SMS) - they contain only public information</li>
                    <li>Use reasonable password lengths: 12-20 characters is typically secure and usable</li>
                    <li>The tool auto-selects or generates keypairs as needed for convenience</li>
                    <li>Multiple keypairs can be maintained in the same session for different exchanges</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="container">
        <h1>üîê DH Key Exchange Password Generator</h1>

        <!-- Welcome Banner (shown when partner token detected in URL) -->
        <div id="welcomeWrapper" class="hidden">
            <div id="welcomeBanner" class="welcome-banner">
                <div class="welcome-banner-icon">üëã</div>
                <div class="welcome-banner-text">
                    <p><strong>It looks like someone sent you here!</strong> A partner token was detected. It has been pre-filled into the "Partner's Token" field below. Remember to send "Your Token" token to this partner, after modifying the password parameters. <a href="#" onclick="openHelpModal(); return false;">Need help?</a></p>
                </div>
                <button class="welcome-banner-close" onclick="closeWelcomeBanner()">&times;</button>
            </div>
        </div>

        <!-- Section 0: Results (at top) -->
        <div id="resultsSection" class="hidden">
            <div class="result-box">
                <h3>‚ú® Shared Password Generated</h3>
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 15px;">
                    <div class="result-item">
                        <label>Shared Password</label>
                        <div class="result-value">
                            <span id="sharedPassword"></span>
                            <button class="copy-button" id="copyPassword">Copy</button>
                        </div>
                    </div>

                    <div class="result-item">
                        <label>Verification Token</label>
                        <div class="result-value verification-token">
                            <span id="verificationToken"></span>
                            <button class="copy-button" id="copyVerification">Copy</button>
                        </div>
                    </div>
                </div>

                <div class="alert alert-warning" style="margin-top: 15px;">
                    ‚ö†Ô∏è Compare the verification token with your partner to ensure you both derived the same password. The tokens should match exactly.
                </div>
            </div>
        </div>

        <!-- Section 1: Password Constraints -->
        <div class="section">
            <h2>‚öôÔ∏è Password Constraints</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <!-- Your Constraints -->
                <div>
                    <h3 style="color: #667eea; margin-bottom: 15px; font-size: 1.1em;">Your Constraints</h3>
                    <div class="section-content">
                        <div class="form-group">
                            <label>Password Length Range</label>
                            <div class="range-inputs">
                                <div>
                                    <input type="number" id="minLength" min="4" max="128" value="16" placeholder="Min">
                                </div>
                                <div>
                                    <input type="number" id="maxLength" min="4" max="128" value="32" placeholder="Max">
                                </div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>Character Sets</label>
                            <div class="checkbox-group">
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charUppercase" checked>
                                    <label for="charUppercase">Uppercase (A-Z)</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charLowercase" checked>
                                    <label for="charLowercase">Lowercase (a-z)</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charNumbers" checked>
                                    <label for="charNumbers">Numbers (0-9)</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charSpecial" checked>
                                    <label for="charSpecial">Special (!@#$...)</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charSimilar" checked>
                                    <label for="charSimilar">Similar (O0Il1)</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charWhitespace">
                                    <label for="charWhitespace">Whitespace</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charDiacritics">
                                    <label for="charDiacritics">Diacritics (√†√©√Æ√≥√º)</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charEmoji">
                                    <label for="charEmoji">Emoji (üòÄüëç‚ú®)</label>
                                </div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>Excluded Characters (optional)</label>
                            <input type="text" id="excludedChars" placeholder="e.g., &quot;#&grave;'&acute;">
                        </div>
                    </div>
                </div>

                <!-- Partner Constraints -->
                <div id="partnerConstraintsPanel">
                    <h3 style="color: #ffa726; margin-bottom: 15px; font-size: 1.1em;">Partner's Constraints</h3>
                    <div class="section-content">
                        <div id="partnerConstraintsContent" class="alert alert-info">
                            Waiting for partner's parameters...
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 3: Exchange Parameters -->
        <div class="section">
            <h2>üîÑ Exchange Parameters</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <!-- Share Your Parameters -->
                <div id="shareSection" class="hidden">
                    <h3 style="color: #667eea; margin-bottom: 15px; font-size: 1.1em;">üì§ Your Token</h3>
                    <div class="section-content">
                        <div class="form-group">
                            <label>Parameter Token</label>
                            <div class="token-display" id="myToken"></div>
                            <div class="button-group" style="margin-top: 10px;">
                                <button class="copy-button" id="copyToken">Copy Token</button>
                                <button class="copy-button" id="copyLink">Copy Link</button>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>Direct Link</label>
                            <input type="text" id="shareLink" readonly style="font-size: 0.8em;">
                        </div>
                    </div>
                </div>

                <!-- Load Partner's Parameters -->
                <div>
                    <h3 style="color: #ffa726; margin-bottom: 15px; font-size: 1.1em;">üì• Partner's Token</h3>
                    <div class="section-content">
                        <div class="form-group">
                            <label>Partner's Parameter Token</label>
                            <textarea id="partnerToken" placeholder="Paste partner's token here..."></textarea>
                        </div>

                        <div class="button-group">
                            <button id="loadPartnerToken">Load Partner's Token</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 4: Key Generation (at bottom) -->
        <div class="section">
            <h2>üîë Key Generation</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <!-- Key Settings -->
                <div>
                    <h3 style="color: #667eea; margin-bottom: 15px; font-size: 1.1em;">Key Settings</h3>
                    <div class="section-content">
                        <div class="form-group">
                            <label>Elliptic Curve</label>
                            <select id="ecCurve">
                                <option value="P-256" selected>P-256 (Default)</option>
                                <option value="P-384">P-384</option>
                                <option value="P-521">P-521</option>
                            </select>
                        </div>

                        <div class="button-group">
                            <button id="generateKeypair">Generate New Keypair</button>
                        </div>
                    </div>
                </div>

                <!-- Key History -->
                <div>
                    <h3 style="color: #667eea; margin-bottom: 15px; font-size: 1.1em;">Key History</h3>
                    <div class="section-content">
                        <div id="keypairListContainer" class="hidden">
                            <div id="keypairList" class="keypair-list"></div>
                        </div>
                        <div id="noKeypairsMessage" class="alert alert-info">
                            No keypairs generated yet. Select a curve to auto-generate one.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // State Management
        // ========================================
        const state = {
            keypairs: [],
            activeKeypairId: null,
            partnerPublicKey: null,
            partnerPublicKeyRaw: null,
            partnerKeypairId: null,
            partnerCurve: null,
            myKeypairIdForPartner: null,
            constraints: null
        };

        // ========================================
        // Utility Functions
        // ========================================
        function generateId(length = 8) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let id = '';
            const array = new Uint8Array(length);
            crypto.getRandomValues(array);
            for (let i = 0; i < length; i++) {
                id += chars[array[i] % chars.length];
            }
            return id;
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.length; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function getConstraints() {
            return {
                minLength: parseInt(document.getElementById('minLength').value),
                maxLength: parseInt(document.getElementById('maxLength').value),
                uppercase: document.getElementById('charUppercase').checked,
                lowercase: document.getElementById('charLowercase').checked,
                numbers: document.getElementById('charNumbers').checked,
                special: document.getElementById('charSpecial').checked,
                similar: document.getElementById('charSimilar').checked,
                whitespace: document.getElementById('charWhitespace').checked,
                diacritics: document.getElementById('charDiacritics').checked,
                emoji: document.getElementById('charEmoji').checked,
                excluded: document.getElementById('excludedChars').value
            };
        }

        function buildCharacterSet(constraints) {
            let charset = '';
            if (constraints.uppercase) charset += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            if (constraints.lowercase) charset += 'abcdefghijklmnopqrstuvwxyz';
            if (constraints.numbers) charset += '0123456789';
            if (constraints.special) charset += '!@#$%^&*()_+-=[]{}|;:,.<>?';
            if (constraints.whitespace) charset += ' \t';
            if (constraints.diacritics) charset += '√†√°√¢√§√®√©√™√´√¨√≠√Æ√Ø√≤√≥√¥√∂√π√∫√ª√º√ß√±√£√µ√Ä√Å√Ç√Ñ√à√â√ä√ã√å√ç√é√è√í√ì√î√ñ√ô√ö√õ√ú√á√ë√É√ï';
            if (constraints.emoji) {
              charset += 'üòÄüòÅüòÇüòÉüòÑüòÖüòÜüòáüòàüòâüòäüòãüòåüòçüòéüòèüòêüòëüòíüòìüòîüòïüòñüòóüòòüòôüòöüòõüòúüòùüòûüòüüò†üò°üò¢üò£üò§üò•üò¶üòßüò®üò©üò™üò´üò¨üò≠üòÆüòØüò∞üò±üò≤üò≥üò¥üòµüò∂üò∑üò∏üòπüò∫üòªüòºüòΩüòæüòøüôÄüôÅüôÇüôÉüôÑ';
              charset += 'üôÖüôÜüôáüôàüôâüôäüôãüôåüôçüôéüôè';
              charset += 'üöÄüöÅüöÇüöÉüöÑüöÖüöÜüöáüöàüöâüöäüöãüöåüöçüöéüöèüöêüöëüöíüöìüöîüöïüöñüöóüöòüöôüööüöõüöúüöùüöûüöüüö†üö°üö¢üö£üö§üö•üö¶üößüö®üö©üö™üö´üö¨üö≠üöÆüöØüö∞üö±üö≤üö≥üö¥üöµüö∂üö∑üö∏üöπüö∫üöªüöºüöΩüöæüöø';
              charset += 'üõÄüõÅüõÇüõÉüõÑüõÖ';
              charset += 'ü§êü§ëü§íü§ìü§îü§ïü§ñü§óü§òü§ôü§öü§õü§úü§ùü§ûü§üü§†ü§°ü§¢ü§£ü§§ü§•ü§¶ü§ßü§®ü§©ü§™ü§´ü§¨ü§≠ü§Æü§Øü§∞ü§±ü§≤ü§≥ü§¥ü§µü§∂ü§∑ü§∏ü§πü§∫ü§ºü§Ωü§æ';
              charset += 'ü•Äü•Åü•Çü•Éü•Ñü•Öü•áü•àü•âü•äü•ãü•åü•çü•éü•èü•êü•ëü•íü•ìü•îü•ïü•ñü•óü•òü•ôü•öü•õü•úü•ùü•ûü•üü•†ü•°ü•¢ü•£ü•§ü••ü•¶ü•ßü•®ü•©ü•™ü•´ü•¨ü•≠ü•Æü•Øü•∞ü•±ü•≥ü•¥ü•µü•∂ü•∫ü•ªü•ºü•Ωü•æü•ø';
              charset += 'ü¶Äü¶Åü¶Çü¶Éü¶Ñü¶Öü¶Üü¶áü¶àü¶âü¶äü¶ãü¶åü¶çü¶éü¶èü¶êü¶ëü¶íü¶ìü¶îü¶ïü¶ñü¶óü¶òü¶ôü¶öü¶õü¶úü¶ùü¶ûü¶üü¶†ü¶°ü¶¢ü¶∏ü¶πü¶∫ü¶ªü¶ºü¶Ωü¶æü¶ø';
              charset += 'üßÄüßÅüßÇüßêüßëüßíüßìüßîüßïüßñüßóüßòüßôüßöüßõüßúüßùüßûüßüüß†üß°üß¢üß£üß§üß•üß¶üßßüß®üß©üß™üß´üß¨üß≠üßÆüßØüß∞üß±üß≤üß≥üß¥üßµüß∂üß∑üß∏üßπüß∫üßªüßºüßΩüßæüßø';
              charset += 'üåÄüåÅüåÇüåÉüåÑüåÖüåÜüåáüåàüåâüåäüåãüååüåçüåéüåèüåêüåëüåíüåìüåîüåïüåñüåóüåòüåôüåöüåõüåúüåùüåûüåüüå†üå≠üåÆüåØüå∞üå±üå≤üå≥üå¥üåµüå∂üå∑üå∏üåπüå∫üåªüåºüåΩüåæüåøüçÄüçÅüçÇüçÉ';
              charset += 'üçÑüçÖüçÜüçáüçàüçâüçäüçãüçåüççüçéüçèüçêüçëüçíüçìüçîüçïüçñüçóüçòüçôüçöüçõüçúüçùüçûüçüüç†üç°üç¢üç£üç§üç•üç¶üçßüç®üç©üç™üç´üç¨üç≠üçÆüçØüç∞üç±üç≤üç≥üç¥üçµüç∂üç∑üç∏üçπüç∫üçªüçºüéÅüéÇüéÉüéÑüéÖüéÜüéáüéàüéâüéäüéãüéåüéçüééüéèüéêüéëüéíüéì';
              charset += 'üé†üé°üé¢üé£üé§üé•üé¶üéßüé®üé©üé™üé´üé¨üé≠üéÆüéØüé∞üé±üé≤üé≥üé¥üéµüé∂üé∑üé∏üéπüé∫üéªüéºüéΩüéæüéøüèÄüèÅüèÇüèÉüèÑüèÖüèÜüèáüèàüèâüèäüèãüèåüèèüèêüèëüèíüèìüè°üè¢üè£üè§üè•üè¶üèßüè®üè©üè™üè´üè¨üè≠üèÆüèØüè∞';
              charset += 'üêÄüêÅüêÇüêÉüêÑüêÖüêÜüêáüêàüêâüêäüêãüêåüêçüêéüêèüêêüêëüêíüêìüêîüêïüêñüêóüêòüêôüêöüêõüêúüêùüêûüêüüê†üê°üê¢üê£üê§üê•üê¶üêßüê®üê©üê™üê´üê¨üê≠üêÆüêØüê∞üê±üê≤üê≥üê¥üêµüê∂üê∑üê∏üêπüê∫üêªüêºüêΩüêæüêø';
              charset += 'üëÄüëÅüëÇüëÉüëÑüëÖüëÜüëáüëàüëâüëäüëãüëåüëçüëéüëèüëêüëëüëíüëìüëîüëïüëñüëóüëòüëôüëöüëõüëúüëùüëûüëüüë†üë°üë¢üë£üë§üë•üë¶üëßüë®üë©üë™üë´üë¨üë≠üëÆüëØüë∞üë±üë≤üë≥üë¥üëµüë∂üë∑üë∏üëπüë∫üëªüëºüëΩüëæüëøüíÄ';
              charset += 'üíÅüíÇüíÉüíÑüíÖüíÜüíáüíàüíâüíäüíãüíåüíçüíéüíèüíêüíëüííüíìüíîüíïüíñüíóüíòüíôüíöüíõüíúüíùüíûüíüüí†üí°üí¢üí£üí§üí•üí¶üíßüí®üí©üí™üí´üí¨üí≠üíÆüíØüí∞üí±üí≤üí≥üí¥üíµüí∂üí∑üí∏üíπüí∫üíªüíºüíΩüíæüíøüìÄüìÅüìÇüìÉüìÑüìÖüìÜüìáüìàüìâüìäüìãüìåüìçüìéüìè';
              charset += 'üìêüìëüìíüììüìîüìïüìñüìóüìòüìôüìöüìõüìúüìùüìûüìüüì†üì°üì¢üì£üì§üì•üì¶üìßüì®üì©üì™üì´üì¨üì≠üìÆüìØüì∞üì±üì≤üì≥üì¥üìµüì∂üì∑üì∏üìπüì∫üìªüìºüìΩüìøüîÄüîÅüîÇüîÉüîÑüîÖüîÜüîáüîàüîâüîäüîãüîåüîçüîéüîèüîêüîëüîíüîìüîîüîïüîñüîóüîòüîôüîöüîõüîúüîùüîûüîüüî†üî°üî¢üî£üî§';
              charset += 'üî•üî¶üîßüî®üî©üî™üî´üî¨üî≠üîÆüîØüî∞üî±üî≤üî≥üî¥üîµüî∂üî∑üî∏üîπüî∫üîªüîºüîΩüïåüïçüïéüïêüïëüïíüïìüïîüïïüïñüïóüïòüïôüïöüïõüïúüïùüïûüïüüï†üï°üï¢üï£üï§üï•üï¶üïß';
            }

            if (!constraints.similar) {
                charset = charset.replace(/[O0Il1|]/g, '');
            }

            if (constraints.excluded) {
                const excluded = constraints.excluded.split('');
                return Array.from(charset).filter(c => !excluded.includes(c));
            } else {
                return Array.from(charset);
            }
        }

        function copyToClipboard(text, buttonId) {
            navigator.clipboard.writeText(text).then(() => {
                const button = document.getElementById(buttonId);
                const originalText = button.textContent;
                button.textContent = '‚úì Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            });
        }

        function highlightCommonConstraints(mergedConstraints) {
            // Add highlighting to checkboxes that are active in merged constraints
            const checkboxes = ['charUppercase', 'charLowercase', 'charNumbers', 'charSpecial', 'charSimilar', 'charWhitespace', 'charDiacritics', 'charEmoji'];
            const constraintKeys = ['uppercase', 'lowercase', 'numbers', 'special', 'similar', 'whitespace', 'diacritics', 'emoji'];
            
            checkboxes.forEach((id, index) => {
                const checkbox = document.getElementById(id);
                const label = checkbox.parentElement;
                const key = constraintKeys[index];
                
                if (mergedConstraints[key]) {
                    // Highlight as common
                    label.style.backgroundColor = '#c8e6c9';
                    label.style.padding = '5px';
                    label.style.borderRadius = '4px';
                    label.style.fontWeight = 'bold';
                } else {
                    // Reset highlighting
                    label.style.backgroundColor = '';
                    label.style.padding = '';
                    label.style.borderRadius = '';
                    label.style.fontWeight = '';
                }
            });
        }

        // ========================================
        // Cryptographic Functions
        // ========================================
        async function generateKeypair(curveName) {
            const keypair = await crypto.subtle.generateKey(
                {
                    name: 'ECDH',
                    namedCurve: curveName
                },
                true,
                ['deriveBits']
            );

            const publicKeyRaw = await crypto.subtle.exportKey('raw', keypair.publicKey);
            const keypairId = generateId(6);

            const keypairData = {
                id: keypairId,
                curve: curveName,
                publicKey: keypair.publicKey,
                privateKey: keypair.privateKey,
                publicKeyRaw: publicKeyRaw,
                timestamp: Date.now()
            };

            state.keypairs.push(keypairData);
            state.activeKeypairId = keypairId;

            // Store in sessionStorage
            saveKeypairsToSession();

            return keypairData;
        }

        async function saveKeypairsToSession() {
            // Export keys as JWK for storage
            const sessionData = [];
            for (const kp of state.keypairs) {
                const publicKeyJWK = await crypto.subtle.exportKey('jwk', kp.publicKey);
                const privateKeyJWK = await crypto.subtle.exportKey('jwk', kp.privateKey);
                sessionData.push({
                    id: kp.id,
                    curve: kp.curve,
                    publicKeyRaw: arrayBufferToBase64(kp.publicKeyRaw),
                    publicKeyJWK: publicKeyJWK,
                    privateKeyJWK: privateKeyJWK,
                    timestamp: kp.timestamp
                });
            }
            sessionStorage.setItem('dhkex_keypairs', JSON.stringify(sessionData));
            sessionStorage.setItem('dhkex_active', state.activeKeypairId);
        }

        async function deriveSharedSecret(privateKey, publicKey, bits = 256) {
            const sharedSecret = await crypto.subtle.deriveBits(
                {
                    name: 'ECDH',
                    public: publicKey
                },
                privateKey,
                256
            );
            const result = await crypto.subtle.deriveBits(
                {
                    name: 'HKDF',
                    hash: 'SHA-256',
                    salt: new Uint8Array([]),
                    info: new Uint8Array([])
                },
                await crypto.subtle.importKey('raw', sharedSecret, { name: 'HKDF' }, false, ['deriveBits']),
                bits
            );
            return new Uint8Array(result);
        }

        function generateVerificationToken(myPublicKeyRaw, partnerPublicKeyRaw, constraints, bits = 24) {
            const myBytes = new Uint8Array(myPublicKeyRaw);
            const partnerBytes = new Uint8Array(partnerPublicKeyRaw);

            // XOR the public keys
            const maxLen = Math.max(myBytes.length, partnerBytes.length);
            const xorResult = new Uint8Array(maxLen);
            
            for (let i = 0; i < maxLen; i++) {
                const myByte = i < myBytes.length ? myBytes[i] : 0;
                const partnerByte = i < partnerBytes.length ? partnerBytes[i] : 0;
                xorResult[i] = myByte ^ partnerByte;
            }

            // Incorporate constraints into the verification token
            // Serialize constraints to bytes
            const constraintsString = JSON.stringify({
                minLength: constraints.minLength,
                maxLength: constraints.maxLength,
                uppercase: constraints.uppercase,
                lowercase: constraints.lowercase,
                numbers: constraints.numbers,
                special: constraints.special,
                similar: constraints.similar,
                whitespace: constraints.whitespace,
                diacritics: constraints.diacritics,
                emoji: constraints.emoji,
                excluded: constraints.excluded
            });
            const encoder = new TextEncoder();
            const constraintsBytes = encoder.encode(constraintsString);

            // XOR constraints into the result
            for (let i = 0; i < constraintsBytes.length; i++) {
                xorResult[i % xorResult.length] ^= constraintsBytes[i];
            }

            // Divide into blocks and XOR them together
            const blockSize = Math.ceil(bits / 8);
            let finalBlock = new Uint8Array(blockSize);
            
            for (let i = 0; i < xorResult.length; i++) {
                finalBlock[i % blockSize] ^= xorResult[i];
            }

            // Convert to hex string (limited to requested bits)
            let hexString = '';
            const numBytes = Math.ceil(bits / 8);
            for (let i = 0; i < numBytes; i++) {
                hexString += finalBlock[i].toString(16).padStart(2, '0');
            }

            // Trim to exact bit count
            const hexChars = Math.ceil(bits / 4);
            return hexString.substring(0, hexChars).toUpperCase();
        }

        function derivePassword(sharedSecret, charset, targetLength) {
            if (charset.length === 0) {
                throw new Error('No character set selected');
            }

            // Use the shared secret to generate a password
            // We'll use the bytes of the shared secret to index into the charset
            let password = '';
            let byteOffset = 0;

            for (let i = 0; i < targetLength; i++) {
                // Use each byte to select a character from the charset
                // For better distribution, we'll use multiple bytes if charset is large
                let index;
                if (charset.length <= 256) {
                    index = sharedSecret[byteOffset] % charset.length;
                    byteOffset++;
                } else {
                    // Use two bytes for larger charsets
                    const byte1 = sharedSecret[byteOffset];
                    const byte2 = sharedSecret[byteOffset + 1];
                    index = ((byte1 << 8) | byte2) % charset.length;
                    byteOffset += 2;
                }
                password += charset[index];
            }

            return password;
        }

        // ========================================
        // Token Management (TLV Encoding)
        // ========================================
        // TLV Tags:
        // 0x01: Keypair ID (string)
        // 0x02: Public Key (binary)
        // 0x03: Curve (1 byte: 0=P-256, 1=P-384, 2=P-521)
        // 0x04: Min Length (1 byte)
        // 0x05: Max Length (1 byte)
        // 0x06: Charset Flags (variable length, bit-packed)
        //       Byte 0: bit 0=uppercase, 1=lowercase, 2=numbers, 3=special, 4=similar, 5=whitespace, 6=diacritics, 7=emoji
        // 0x07: Excluded chars (string)
        // 0x08: Partner Keypair ID (string) - ID of the keypair that should be used to respond

        function encodeTLV(tag, value) {
            let valueBytes;
            
            if (typeof value === 'string') {
                const encoder = new TextEncoder();
                valueBytes = encoder.encode(value);
            } else if (typeof value === 'number') {
                valueBytes = new Uint8Array([value]);
            } else if (value instanceof ArrayBuffer || value instanceof Uint8Array) {
                valueBytes = new Uint8Array(value);
            } else {
                throw new Error('Unsupported value type for TLV encoding');
            }

            const length = valueBytes.length;
            let result;

            if (length < 128) {
                // Short form: 1 byte length
                result = new Uint8Array(2 + length);
                result[0] = tag;
                result[1] = length;
                result.set(valueBytes, 2);
            } else {
                // Long form: 2 bytes length (supports up to 65535)
                result = new Uint8Array(4 + length);
                result[0] = tag;
                result[1] = 0x80 | 0x02; // Length is encoded in next 2 bytes
                result[2] = (length >> 8) & 0xFF;
                result[3] = length & 0xFF;
                result.set(valueBytes, 4);
            }

            return result;
        }

        function decodeTLV(buffer, offset) {
            const view = new Uint8Array(buffer);
            
            if (offset >= view.length) {
                return null;
            }

            const tag = view[offset];
            let length;
            let valueOffset;

            if (view[offset + 1] & 0x80) {
                // Long form
                const lengthBytes = view[offset + 1] & 0x7F;
                if (lengthBytes === 2) {
                    length = (view[offset + 2] << 8) | view[offset + 3];
                    valueOffset = offset + 4;
                } else {
                    throw new Error('Unsupported length encoding');
                }
            } else {
                // Short form
                length = view[offset + 1];
                valueOffset = offset + 2;
            }

            const value = view.slice(valueOffset, valueOffset + length);
            const nextOffset = valueOffset + length;

            return { tag, value, nextOffset };
        }

        function createToken(keypairId, publicKeyRaw, curve, constraints, partnerKeypairId = null) {
            const parts = [];

            // Tag 0x01: Keypair ID
            parts.push(encodeTLV(0x01, keypairId));

            // Tag 0x02: Public Key
            parts.push(encodeTLV(0x02, publicKeyRaw));

            // Tag 0x03: Curve (encode as number)
            const curveMap = { 'P-256': 0, 'P-384': 1, 'P-521': 2 };
            parts.push(encodeTLV(0x03, curveMap[curve] || 0));

            // Tag 0x04: Min Length
            parts.push(encodeTLV(0x04, constraints.minLength));

            // Tag 0x05: Max Length
            parts.push(encodeTLV(0x05, constraints.maxLength));

            // Tag 0x06: Charset Flags (multi-byte support)
            let flags = 0;
            if (constraints.uppercase) flags |= 0x01;
            if (constraints.lowercase) flags |= 0x02;
            if (constraints.numbers) flags |= 0x04;
            if (constraints.special) flags |= 0x08;
            if (constraints.similar) flags |= 0x10;
            if (constraints.whitespace) flags |= 0x20;
            if (constraints.diacritics) flags |= 0x40;
            if (constraints.emoji) flags |= 0x80;
            
            // Only add if flags is non-zero
            if (flags !== 0) {
                parts.push(encodeTLV(0x06, flags));
            }

            // Tag 0x07: Excluded chars (only if non-empty)
            if (constraints.excluded) {
                parts.push(encodeTLV(0x07, constraints.excluded));
            }

            // Tag 0x08: Partner Keypair ID (only if provided)
            if (partnerKeypairId) {
                parts.push(encodeTLV(0x08, partnerKeypairId));
            }

            // Concatenate all parts
            const totalLength = parts.reduce((sum, part) => sum + part.length, 0);
            const result = new Uint8Array(totalLength);
            let offset = 0;
            for (const part of parts) {
                result.set(part, offset);
                offset += part.length;
            }

            // Base64 encode the binary TLV data
            return arrayBufferToBase64(result.buffer);
        }

        function parseToken(tokenString) {
            try {
                const buffer = base64ToArrayBuffer(tokenString);
                const result = {
                    keypairId: null,
                    publicKeyRaw: null,
                    curve: null,
                    partnerKeypairId: null,
                    constraints: {
                        minLength: 16,
                        maxLength: 32,
                        uppercase: true,
                        lowercase: true,
                        numbers: true,
                        special: true,
                        similar: true,
                        whitespace: false,
                        diacritics: false,
                        emoji: false,
                        excluded: ''
                    }
                };

                const curveMap = ['P-256', 'P-384', 'P-521'];
                let offset = 0;

                while (offset < buffer.byteLength) {
                    const tlv = decodeTLV(buffer, offset);
                    if (!tlv) break;

                    const decoder = new TextDecoder();

                    switch (tlv.tag) {
                        case 0x01: // Keypair ID
                            result.keypairId = decoder.decode(tlv.value);
                            break;
                        case 0x02: // Public Key
                            result.publicKeyRaw = tlv.value.buffer;
                            break;
                        case 0x03: // Curve
                            result.curve = curveMap[tlv.value[0]] || 'P-256';
                            break;
                        case 0x04: // Min Length
                            result.constraints.minLength = tlv.value[0];
                            break;
                        case 0x05: // Max Length
                            result.constraints.maxLength = tlv.value[0];
                            break;
                        case 0x06: // Charset Flags
                            const flags = tlv.value[0];
                            result.constraints.uppercase = !!(flags & 0x01);
                            result.constraints.lowercase = !!(flags & 0x02);
                            result.constraints.numbers = !!(flags & 0x04);
                            result.constraints.special = !!(flags & 0x08);
                            result.constraints.similar = !!(flags & 0x10);
                            result.constraints.whitespace = !!(flags & 0x20);
                            result.constraints.diacritics = !!(flags & 0x40);
                            result.constraints.emoji = !!(flags & 0x80);
                            break;
                        case 0x07: // Excluded chars
                            result.constraints.excluded = decoder.decode(tlv.value);
                            break;
                        case 0x08: // Partner Keypair ID
                            result.partnerKeypairId = decoder.decode(tlv.value);
                            break;
                    }

                    offset = tlv.nextOffset;
                }

                return result;
            } catch (e) {
                console.error('Failed to parse token:', e);
                return null;
            }
        }

        // ========================================
        // Intelligent Key Management
        // ========================================
        async function ensureKeypairForCurve(curveName) {
            // Find the latest keypair for this curve
            const matchingKeys = state.keypairs.filter(kp => kp.curve === curveName);
            
            if (matchingKeys.length > 0) {
                // Sort by timestamp, newest first
                matchingKeys.sort((a, b) => b.timestamp - a.timestamp);
                const latestKey = matchingKeys[0];
                state.activeKeypairId = latestKey.id;
                updateKeypairList();
                updateShareSection();
                return latestKey;
            } else {
                // No matching keypair, generate one
                console.log('Auto-generating keypair for curve: ' + curveName);
                const newKeypair = await generateKeypair(curveName);
                updateKeypairList();
                updateShareSection();
                return newKeypair;
            }
        }

        // ========================================
        // Intelligent Key Management
        // ========================================
        async function ensureKeypairForCurve(curveName) {
            // Find the latest keypair for this curve
            const matchingKeys = state.keypairs.filter(kp => kp.curve === curveName);
            
            if (matchingKeys.length > 0) {
                // Sort by timestamp, newest first
                matchingKeys.sort((a, b) => b.timestamp - a.timestamp);
                const latestKey = matchingKeys[0];
                state.activeKeypairId = latestKey.id;
                updateKeypairList();
                updateShareSection();
                return latestKey;
            } else {
                // No matching keypair, generate one
                console.log('Auto-generating keypair for curve: ' + curveName);
                const newKeypair = await generateKeypair(curveName);
                updateKeypairList();
                updateShareSection();
                return newKeypair;
            }
        }

        // ========================================
        // UI Update Functions
        // ========================================
        function updateKeypairList() {
            const container = document.getElementById('keypairListContainer');
            const list = document.getElementById('keypairList');
            const noKeysMsg = document.getElementById('noKeypairsMessage');

            if (state.keypairs.length === 0) {
                container.classList.add('hidden');
                noKeysMsg.classList.remove('hidden');
                return;
            }

            container.classList.remove('hidden');
            noKeysMsg.classList.add('hidden');
            list.innerHTML = '';

            state.keypairs.forEach(kp => {
                const item = document.createElement('div');
                item.className = 'keypair-item' + (kp.id === state.activeKeypairId ? ' active' : '');
                const timestamp = new Date(kp.timestamp).toLocaleString();
                item.innerHTML = `
                    <div class="keypair-info">
                        <span class="keypair-id">ID: ${kp.id}</span>
                        <span class="keypair-curve">Curve: ${kp.curve}</span>
                        <span class="keypair-curve">Created: ${timestamp}</span>
                    </div>
                    <button class="copy-button" onclick="setActiveKeypair('${kp.id}')">
                        ${kp.id === state.activeKeypairId ? 'Active' : 'Select'}
                    </button>
                `;
                list.appendChild(item);
            });
        }

        function updateShareSection() {
            const activeKeypair = state.keypairs.find(kp => kp.id === state.activeKeypairId);
            if (!activeKeypair) {
                document.getElementById('shareSection').classList.add('hidden');
                return;
            }

            const constraints = getConstraints();
            const token = createToken(
                activeKeypair.id,
                activeKeypair.publicKeyRaw,
                activeKeypair.curve,
                constraints,
                state.myKeypairIdForPartner
            );

            document.getElementById('myToken').textContent = token;
            
            const link = window.location.href.split('?')[0] + '?token=' + encodeURIComponent(token);
            document.getElementById('shareLink').value = link;

            document.getElementById('shareSection').classList.remove('hidden');
        }

        async function processPartnerToken(tokenString) {
            const parsed = parseToken(tokenString);
            if (!parsed) {
                alert('Invalid token format');
                return;
            }

            // Import the partner's public key
            const partnerPublicKey = await crypto.subtle.importKey(
                'raw',
                parsed.publicKeyRaw,
                {
                    name: 'ECDH',
                    namedCurve: parsed.curve
                },
                false,
                []
            );

            state.partnerPublicKey = partnerPublicKey;
            state.partnerPublicKeyRaw = parsed.publicKeyRaw;
            state.partnerKeypairId = parsed.keypairId;
            state.partnerCurve = parsed.curve;
            
            // If partner specified which keypair we should use, check if we have it
            if (parsed.partnerKeypairId) {
                const targetKeypair = state.keypairs.find(kp => kp.id === parsed.partnerKeypairId);
                if (targetKeypair) {
                    state.activeKeypairId = parsed.partnerKeypairId;
                    updateKeypairList(); // Update UI to show active keypair
                } else {
                    // Show error - we don't have the requested keypair
                    const partnerPanel = document.getElementById('partnerConstraintsContent');
                    partnerPanel.innerHTML = `
                        <div class="alert" style="background: #ffebee; border: 1px solid #ef5350; color: #c62828;">
                            <strong>‚ö†Ô∏è Error: Missing Keypair</strong><br>
                            Partner requested keypair ID <strong>${parsed.partnerKeypairId}</strong> but it was not found in your key history.<br>
                            This token was meant as a response to a specific keypair you previously shared.
                        </div>
                    `;
                    return; // Don't proceed with password generation
                }
            }
            
            // Store partner's keypair ID so our response token includes it
            state.myKeypairIdForPartner = parsed.keypairId;
            
            // Merge constraints (take the most restrictive)
            const currentConstraints = getConstraints();
            state.constraints = {
                minLength: Math.max(parsed.constraints.minLength, currentConstraints.minLength),
                maxLength: Math.min(parsed.constraints.maxLength, currentConstraints.maxLength),
                uppercase: parsed.constraints.uppercase && currentConstraints.uppercase,
                lowercase: parsed.constraints.lowercase && currentConstraints.lowercase,
                numbers: parsed.constraints.numbers && currentConstraints.numbers,
                special: parsed.constraints.special && currentConstraints.special,
                similar: parsed.constraints.similar && currentConstraints.similar,
                whitespace: parsed.constraints.whitespace && currentConstraints.whitespace,
                diacritics: parsed.constraints.diacritics && currentConstraints.diacritics,
                emoji: parsed.constraints.emoji && currentConstraints.emoji,
                excluded: (parsed.constraints.excluded + currentConstraints.excluded).split('').filter((v, i, a) => a.indexOf(v) === i).join('')
            };

            // Show partner constraints in the side panel
            const partnerPanel = document.getElementById('partnerConstraintsContent');
            partnerPanel.innerHTML = `
                <div style="padding: 10px; background: white; border-radius: 6px;">
                    <p style="margin-bottom: 10px;"><strong>üÜî Keypair ID:</strong> ${parsed.keypairId}</p>
                    <p style="margin-bottom: 10px;"><strong>üìê Curve:</strong> ${parsed.curve}</p>
                    <p style="margin-bottom: 10px;"><strong>üìè Length:</strong> ${parsed.constraints.minLength}-${parsed.constraints.maxLength} chars</p>
                    <div style="margin-top: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                        <div>üî§ Uppercase: ${parsed.constraints.uppercase ? '‚úì' : '‚úó'}</div>
                        <div>üî° Lowercase: ${parsed.constraints.lowercase ? '‚úì' : '‚úó'}</div>
                        <div>üî¢ Numbers: ${parsed.constraints.numbers ? '‚úì' : '‚úó'}</div>
                        <div>üî£ Special: ${parsed.constraints.special ? '‚úì' : '‚úó'}</div>
                        <div>üëÅÔ∏è Similar: ${parsed.constraints.similar ? '‚úì' : '‚úó'}</div>
                        <div>‚ê£ Whitespace: ${parsed.constraints.whitespace ? '‚úì' : '‚úó'}</div>
                        <div>√© Diacritics: ${parsed.constraints.diacritics ? '‚úì' : '‚úó'}</div>
                        <div>üòÄ Emoji: ${parsed.constraints.emoji ? '‚úì' : '‚úó'}</div>
                        ${parsed.constraints.excluded ? `<div style="grid-column: 1 / -1;">üö´ Excluded: ${parsed.constraints.excluded}</div>` : ''}
                    </div>
                </div>
            `;
            
            // Highlight common constraints
            highlightCommonConstraints(state.constraints);

            // Update our share section to include partner's keypair ID in our token
            updateShareSection();

            // If we have an active keypair, derive the password
            if (state.activeKeypairId) {
                await deriveAndDisplayPassword();
            }
        }

        async function deriveAndDisplayPassword() {
            const activeKeypair = state.keypairs.find(kp => kp.id === state.activeKeypairId);
            if (!activeKeypair || !state.partnerPublicKey) {
                return;
            }

            // Check curve compatibility
            if (activeKeypair.curve !== state.partnerCurve) {
                alert('Curve mismatch! You are using ' + activeKeypair.curve + ' but partner is using ' + state.partnerCurve);
                return;
            }

            // Build character set and calculate bytes needed
            const charset = buildCharacterSet(state.constraints);
            const targetLength = Math.min(state.constraints.maxLength, Math.floor((state.constraints.minLength + state.constraints.maxLength) / 2));
            const bytesPerChar = charset.length <= 256 ? 1 : 2;
            const bitsNeeded = targetLength * bytesPerChar * 8;

            // Derive shared secret with exactly the number of bits we need
            const sharedSecret = await deriveSharedSecret(activeKeypair.privateKey, state.partnerPublicKey, bitsNeeded);

            // Generate password
            const password = derivePassword(sharedSecret, charset, targetLength);

            // Generate verification token
            const verificationToken = generateVerificationToken(activeKeypair.publicKeyRaw, state.partnerPublicKeyRaw, state.constraints, 24);

            // Display results
            document.getElementById('sharedPassword').textContent = password;
            document.getElementById('verificationToken').textContent = verificationToken;
            document.getElementById('resultsSection').classList.remove('hidden');
        }

        // ========================================
        // Global Functions (for onclick handlers)
        // ========================================
        window.setActiveKeypair = function(keypairId) {
            state.activeKeypairId = keypairId;
            saveKeypairsToSession();
            updateKeypairList();
            updateShareSection();
        };

        // ========================================
        // Event Handlers
        // ========================================
        document.getElementById('generateKeypair').addEventListener('click', async function() {
            const curve = document.getElementById('ecCurve').value;
            const button = this;
            button.disabled = true;
            button.textContent = 'Generating...';

            try {
                await generateKeypair(curve);
                updateKeypairList();
                updateShareSection();
            } catch (e) {
                alert('Failed to generate keypair: ' + e.message);
            } finally {
                button.disabled = false;
                button.textContent = 'Generate New Keypair';
            }
        });

        // Auto-select or generate keypair when curve changes
        document.getElementById('ecCurve').addEventListener('change', async function() {
            const curve = this.value;
            await ensureKeypairForCurve(curve);
        });

        document.getElementById('copyToken').addEventListener('click', function() {
            const token = document.getElementById('myToken').textContent;
            copyToClipboard(token, 'copyToken');
        });

        document.getElementById('copyLink').addEventListener('click', function() {
            const link = document.getElementById('shareLink').value;
            copyToClipboard(link, 'copyLink');
        });

        document.getElementById('loadPartnerToken').addEventListener('click', async function() {
            await loadPartnerTokenFromTextarea();
        });

        // Auto-import partner tokens when pasted
        let partnerTokenTimeout;
        document.getElementById('partnerToken').addEventListener('input', function() {
            clearTimeout(partnerTokenTimeout);
            partnerTokenTimeout = setTimeout(async () => {
                const tokenString = this.value.trim();
                if (tokenString && tokenString.length > 20) { // Basic validation
                    try {
                        // Try to parse to see if it's valid
                        const parsed = parseToken(tokenString);
                        if (parsed && parsed.publicKeyRaw) {
                            console.log('Auto-importing partner token...');
                            await loadPartnerTokenFromTextarea();
                        }
                    } catch (e) {
                        // Invalid token, don't auto-import
                    }
                }
            }, 500); // Wait 500ms after user stops typing
        });

        async function loadPartnerTokenFromTextarea() {
            const tokenString = document.getElementById('partnerToken').value.trim();
            if (!tokenString) {
                alert('Please paste a token first');
                return;
            }

            const button = document.getElementById('loadPartnerToken');
            button.disabled = true;
            button.textContent = 'Loading...';

            try {
                await processPartnerToken(tokenString);
            } catch (e) {
                alert('Failed to process token: ' + e.message);
            } finally {
                button.disabled = false;
                button.textContent = "Load Partner's Token";
            }
        }

        document.getElementById('copyPassword').addEventListener('click', function() {
            const password = document.getElementById('sharedPassword').textContent;
            copyToClipboard(password, 'copyPassword');
        });

        document.getElementById('copyVerification').addEventListener('click', function() {
            const token = document.getElementById('verificationToken').textContent;
            copyToClipboard(token, 'copyVerification');
        });

        // Update share section when constraints change
        ['minLength', 'maxLength', 'charUppercase', 'charLowercase', 'charNumbers', 'charSpecial', 'charSimilar', 'charWhitespace', 'charDiacritics', 'charEmoji', 'excludedChars'].forEach(id => {
            const element = document.getElementById(id);
            element.addEventListener('change', async function() {
                if (state.activeKeypairId) {
                    updateShareSection();
                    if (state.partnerPublicKey) {
                        await processPartnerToken(document.getElementById('partnerToken').value.trim());
                    }
                }
            });
        });

        // ========================================
        // Session Storage Restoration
        // ========================================
        async function restoreKeypairsFromSession() {
            try {
                const savedKeypairs = sessionStorage.getItem('dhkex_keypairs');
                const savedActive = sessionStorage.getItem('dhkex_active');
                
                if (savedKeypairs) {
                    const sessionData = JSON.parse(savedKeypairs);
                    
                    for (const data of sessionData) {
                        // Import keys from JWK
                        const publicKey = await crypto.subtle.importKey(
                            'jwk',
                            data.publicKeyJWK,
                            { name: 'ECDH', namedCurve: data.curve },
                            true,
                            []
                        );
                        
                        const privateKey = await crypto.subtle.importKey(
                            'jwk',
                            data.privateKeyJWK,
                            { name: 'ECDH', namedCurve: data.curve },
                            true,
                            ['deriveBits']
                        );
                        
                        const keypairData = {
                            id: data.id,
                            curve: data.curve,
                            publicKey: publicKey,
                            privateKey: privateKey,
                            publicKeyRaw: base64ToArrayBuffer(data.publicKeyRaw),
                            timestamp: data.timestamp
                        };
                        
                        state.keypairs.push(keypairData);
                    }
                    
                    if (savedActive) {
                        state.activeKeypairId = savedActive;
                    }
                    
                    updateKeypairList();
                    if (state.activeKeypairId) {
                        updateShareSection();
                    }
                    
                    console.log('Restored ' + state.keypairs.length + ' keypair(s) from session');
                }
            } catch (e) {
                console.error('Failed to restore session:', e);
            }
        }

        // ========================================
        // Initialization
        // ========================================
        window.addEventListener('DOMContentLoaded', async function() {
            // Restore keypairs from session storage
            await restoreKeypairsFromSession();

            // Check for token in URL and show welcome banner if appropriate
            const urlParams = new URLSearchParams(window.location.search);
            const tokenParam = urlParams.get('token') || urlParams.get('t');
            
            if (tokenParam) {
                // Show welcome banner if not previously dismissed
                if (!sessionStorage.getItem('welcomeBannerDismissed')) {
                    document.getElementById('welcomeWrapper').classList.remove('hidden');
                }
                
                // Auto-fill the partner token field
                const partnerTokenField = document.getElementById('partnerToken');
                if (partnerTokenField && !partnerTokenField.value) {
                    partnerTokenField.value = tokenParam;
                    // Trigger auto-import
                    partnerTokenField.dispatchEvent(new Event('input'));
                }
            }

            // Ensure we have a keypair for the default curve
            const defaultCurve = document.getElementById('ecCurve').value;
            await ensureKeypairForCurve(defaultCurve);
        });

        // ========================================
        // Help Modal Functions
        // ========================================
        function openHelpModal() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelpModal() {
            document.getElementById('helpModal').classList.remove('active');
        }

        function closeHelpModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeHelpModal();
            }
        }

        function closeWelcomeBanner() {
            document.getElementById('welcomeWrapper').classList.add('hidden');
            sessionStorage.setItem('welcomeBannerDismissed', 'true');
        }
    </script>
</body>
</html>
