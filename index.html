<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DH Key Exchange - Secure Password Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
        }

        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .section {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #fafafa;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-content {
            display: grid;
            gap: 15px;
        }

        .form-group {
            display: grid;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        input[type="number"],
        input[type="text"],
        select,
        textarea {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus,
        input[type="text"]:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .range-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .keypair-list {
            display: grid;
            gap: 10px;
        }

        .keypair-item {
            padding: 12px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
        }

        .keypair-item.active {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .keypair-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .keypair-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .keypair-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .icon-button {
            padding: 2px 4px;
            background: transparent;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.2s;
        }

        .icon-button:hover {
            background: #f0f0f0;
            border-color: #667eea;
        }

        .icon-button.saved {
            color: #4caf50;
            border-color: #4caf50;
            border-width: 2px;
            padding: 1px 3px;
        }

        .icon-button.locked {
            color: #ffa726;
            border-color: #ffa726;
            border-width: 2px;
            padding: 1px 3px;
        }

        .keypair-storage-controls {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e0e0e0;
            display: none;
        }

        .keypair-storage-controls.visible {
            display: block;
        }

        .storage-input-group {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
        }

        .storage-input-group input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .storage-input-group button {
            padding: 8px 16px;
            font-size: 0.9em;
        }

        .storage-hint {
            font-size: 0.8em;
            color: #666;
            font-style: italic;
        }

        .keypair-id {
            font-weight: bold;
            color: #667eea;
        }

        .keypair-curve {
            font-size: 0.85em;
            color: #666;
        }

        .token-display {
            padding: 15px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 6px;
            word-break: break-all;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            max-height: 150px;
            overflow-y: auto;
            position: relative;
        }

        .copy-button {
            padding: 6px 12px;
            font-size: 0.85em;
            background: #28a745;
        }

        .copy-button:hover {
            background: #218838;
        }

        .result-box {
            padding: 20px;
            background: #e8f5e9;
            border: 2px solid #4caf50;
            border-radius: 8px;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .result-box h3 {
            color: #2e7d32;
            margin-bottom: 15px;
        }

        .result-item {
            margin-bottom: 0;
        }

        .result-item label {
            display: block;
            margin-bottom: 5px;
            color: #2e7d32;
        }

        .result-value {
            padding: 12px;
            background: white;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            font-weight: bold;
            word-break: break-all;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .verification-token {
            font-size: 1.5em;
            color: #667eea;
            text-align: center;
        }

        .alert {
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .alert-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .hidden {
            display: none;
        }

        textarea {
            min-height: 100px;
            font-family: 'Courier New', monospace;
            resize: vertical;
        }

        .link-display {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .link-display input {
            flex: 1;
        }

        .help-button {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #667eea;
            color: white;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-y: auto;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 700px;
            width: 100%;
            max-height: 90vh;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5em;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .modal-body {
            padding: 30px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .modal-body h3 {
            color: #667eea;
            margin-top: 25px;
            margin-bottom: 12px;
            font-size: 1.2em;
        }

        .modal-body h3:first-child {
            margin-top: 0;
        }

        .modal-body p {
            line-height: 1.6;
            color: #555;
            margin-bottom: 15px;
        }

        .modal-body ol, .modal-body ul {
            margin-left: 20px;
            margin-bottom: 15px;
            color: #555;
        }

        .modal-body li {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .modal-body strong {
            color: #333;
        }

        .welcome-banner {
            background: linear-gradient(135deg, #667eea15, #764ba215);
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .welcome-banner-icon {
            font-size: 2em;
        }

        .welcome-banner-text {
            flex: 1;
        }

        .welcome-banner-text p {
            margin: 0;
            color: #333;
        }

        .welcome-banner-close {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 1.5em;
            padding: 0;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .welcome-banner-close:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        @media (max-width: 768px) {
            .range-inputs {
                grid-template-columns: 1fr;
            }
            
            .section > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
            }

            .help-button {
                top: 10px;
                right: 10px;
                width: 45px;
                height: 45px;
                font-size: 1.3em;
            }

            .modal-body {
                padding: 20px;
            }
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 3000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
        }

        .toast {
            background: white;
            border-radius: 8px;
            padding: 16px 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 12px;
            animation: slideIn 0.3s ease-out;
            border-left: 4px solid #667eea;
        }

        .toast.success {
            border-left-color: #4caf50;
        }

        .toast.error {
            border-left-color: #f44336;
        }

        .toast.warning {
            border-left-color: #ffa726;
        }

        .toast.info {
            border-left-color: #2196f3;
        }

        .toast-icon {
            font-size: 1.5em;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
            color: #333;
            line-height: 1.4;
        }

        .toast-close {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 1.2em;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            flex-shrink: 0;
            transition: all 0.2s;
        }

        .toast-close:hover {
            background: #f0f0f0;
            color: #333;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .toast.removing {
            animation: slideOut 0.3s ease-out forwards;
        }

        @media (max-width: 768px) {
            .toast-container {
                right: 10px;
                left: 10px;
                max-width: none;
            }

            @keyframes slideIn {
                from {
                    transform: translateY(-100px);
                    opacity: 0;
                }
                to {
                    transform: translateY(0);
                    opacity: 1;
                }
            }

            @keyframes slideOut {
                from {
                    transform: translateY(0);
                    opacity: 1;
                }
                to {
                    transform: translateY(-100px);
                    opacity: 0;
                }
            }
        }

        /* Confirmation Modal */
        .confirm-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2500;
            align-items: center;
            justify-content: center;
        }

        .confirm-overlay.active {
            display: flex;
        }

        .confirm-dialog {
            background: white;
            border-radius: 12px;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .confirm-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .confirm-header h3 {
            margin: 0;
            color: #333;
            font-size: 1.2em;
        }

        .confirm-body {
            padding: 20px;
            color: #555;
            line-height: 1.6;
        }

        .confirm-footer {
            padding: 15px 20px;
            background: #f5f5f5;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .confirm-footer button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            transition: all 0.2s;
        }

        .confirm-cancel {
            background: #e0e0e0;
            color: #555;
        }

        .confirm-cancel:hover {
            background: #d0d0d0;
        }

        .confirm-confirm {
            background: #f44336;
            color: white;
        }

        .confirm-confirm:hover {
            background: #d32f2f;
        }
    </style>
</head>
<body>
    <!-- Help Button -->
    <button class="help-button" onclick="openHelpModal()" title="Help">üõü</button>

    <!-- Help Modal -->
    <div id="helpModal" class="modal-overlay" onclick="closeHelpModalOnOverlay(event)">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üõü Help & Information</h2>
                <button class="modal-close" onclick="closeHelpModal()">&times;</button>
            </div>
            <div class="modal-body">
                <h3>üìã Workflow</h3>
                <ol>
                    <li><strong><span title="User A">üë®üèΩ</span></strong> opens this page and configures password constraints (length, character types, excluded characters)</li>
                    <li><strong><span title="User A">üë®üèΩ</span></strong> generates an EC keypair and shares their token with <strong><span title="User B">üë©üèª</span></strong> (via any channel: email, chat, etc.)</li>
                    <li><strong><span title="User B">üë©üèª</span></strong> opens this page, pastes <strong><span title="User A">üë®üèΩ</span></strong>'s token, which automatically imports the constraints</li>
                    <li><strong><span title="User B">üë©üèª</span></strong> generates their own keypair and shares their token back to <strong><span title="User A">üë®üèΩ</span></strong></li>
                    <li><strong><span title="Both users">üë®üèΩüë©üèª</span></strong> now have matching shared passwords and verification tokens</li>
                    <li><strong>Verify out-of-band</strong>: <span title="Both users">üë®üèΩüë©üèª</span> compare the 6-character verification token (phone call, video chat, etc.)</li>
                    <li><strong>Use the password</strong>: Once verified, both users can use the shared password with confidence</li>
                </ol>

                <h3>üîí Security Principles</h3>
                <p>This tool uses <strong>Elliptic Curve Diffie-Hellman (ECDH)</strong> key exchange:</p>
                <ul>
                    <li><strong>Public Key Cryptography</strong>: Each user generates a keypair (private + public key). Only public keys are exchanged</li>
                    <li><strong>Shared Secret Derivation</strong>: Using ECDH, both parties independently compute the same shared secret without ever transmitting it</li>
                    <li><strong>Password Generation</strong>: The shared secret is deterministically converted to a password using the agreed constraints</li>
                    <li><strong>Verification Token</strong>: A 24-bit token (XOR of public keys) provides out-of-band verification to prevent MITM attacks</li>
                    <li><strong>Web Crypto API</strong>: All cryptography uses browser-native, audited implementations (P-256, P-384, or P-521 curves)</li>
                </ul>

                <h3>üè† Privacy & Security</h3>
                <ul>
                    <li>‚úÖ <strong>100% Client-Side</strong>: All cryptographic operations happen in your browser</li>
                    <li>‚úÖ <strong>No Server Communication</strong>: Zero network requests after loading</li>
                    <li>‚úÖ <strong>No Tracking</strong>: No cookies, no analytics, no telemetry</li>
                    <li>‚úÖ <strong>Optional Persistent Storage</strong>: Save keypairs to localStorage with optional AES-GCM encryption</li>
                    <li>‚úÖ <strong>Open Source</strong>: Single HTML file - view source to audit the code</li>
                </ul>
                <p><em>You control token distribution. This tool only provides the cryptographic mechanism to generate matching passwords.</em></p>

                <h3>üí° Tips</h3>
                <ul>
                    <li><strong>Always verify</strong> the 6-character token out-of-band (phone, video) before using the password</li>
                    <li><strong>Tokens are safe to share</strong> via any medium (email, chat, SMS) - they contain only public information</li>
                    <li><strong>Save keypairs</strong> using the üíæ icon to persist them across sessions with optional password protection</li>
                    <li><strong>Use reasonable lengths</strong>: 12-20 characters is typically secure and usable</li>
                    <li><strong>Multiple keypairs</strong> can be maintained for different exchanges or security zones</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="container">
        <h1>üîê DH Key Exchange Password Generator</h1>

        <!-- Welcome Banner (shown when partner token detected in URL) -->
        <div id="welcomeWrapper" class="hidden">
            <div id="welcomeBanner" class="welcome-banner">
                <div class="welcome-banner-icon">üëã</div>
                <div class="welcome-banner-text">
                    <p><strong>It looks like someone sent you here!</strong> A partner token was detected. It has been pre-filled into the "Partner's Token" field below. Remember to send "Your Token" token to this partner, after modifying the password parameters. <a href="#" onclick="openHelpModal(); return false;">Need help?</a></p>
                </div>
                <button class="welcome-banner-close" onclick="closeWelcomeBanner()">&times;</button>
            </div>
        </div>

        <!-- Section 0: Results (at top) -->
        <div id="resultsSection" class="hidden">
            <div class="result-box">
                <h3>‚ú® Shared Password Generated</h3>
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 15px;">
                    <div class="result-item">
                        <label>Shared Password</label>
                        <div class="result-value">
                            <span id="sharedPassword"></span>
                            <button class="copy-button" id="copyPassword">Copy</button>
                        </div>
                    </div>

                    <div class="result-item">
                        <label>Verification Token</label>
                        <div class="result-value verification-token">
                            <span id="verificationToken"></span>
                            <button class="copy-button" id="copyVerification">Copy</button>
                        </div>
                    </div>
                </div>

                <div class="alert alert-warning" style="margin-top: 15px;">
                    ‚ö†Ô∏è Compare the verification token with your partner to ensure you both derived the same password. The tokens should match exactly.
                </div>
            </div>
        </div>

        <!-- Section 1: Password Constraints -->
        <div class="section">
            <h2>‚öôÔ∏è Password Constraints</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <!-- Your Constraints -->
                <div>
                    <h3 style="color: #667eea; margin-bottom: 15px; font-size: 1.1em;">Your Constraints</h3>
                    <div class="section-content">
                        <div class="form-group">
                            <label>Password Length Range</label>
                            <div class="range-inputs">
                                <div>
                                    <input type="number" id="minLength" min="4" max="128" value="16" placeholder="Min">
                                </div>
                                <div>
                                    <input type="number" id="maxLength" min="4" max="128" value="32" placeholder="Max">
                                </div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>Character Sets</label>
                            <div class="checkbox-group">
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charUppercase" checked>
                                    <label for="charUppercase">Uppercase (A-Z)</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charLowercase" checked>
                                    <label for="charLowercase">Lowercase (a-z)</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charNumbers" checked>
                                    <label for="charNumbers">Numbers (0-9)</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charSpecial" checked>
                                    <label for="charSpecial">Special (!@#$...)</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charSimilar" checked>
                                    <label for="charSimilar">Similar (O0Il1)</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charWhitespace">
                                    <label for="charWhitespace">Whitespace</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charDiacritics">
                                    <label for="charDiacritics">Diacritics (√†√©√Æ√≥√º)</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="charEmoji">
                                    <label for="charEmoji">Emoji (üòÄüëç‚ú®)</label>
                                </div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>Excluded Characters (optional)</label>
                            <input type="text" id="excludedChars" placeholder="e.g., &quot;#&grave;'&acute;">
                        </div>
                    </div>
                </div>

                <!-- Partner Constraints -->
                <div id="partnerConstraintsPanel">
                    <h3 style="color: #ffa726; margin-bottom: 15px; font-size: 1.1em;">Partner's Constraints</h3>
                    <div class="section-content">
                        <div id="partnerConstraintsContent" class="alert alert-info">
                            Waiting for partner's parameters...
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 3: Exchange Parameters -->
        <div class="section">
            <h2>üîÑ Exchange Parameters</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <!-- Share Your Parameters -->
                <div id="shareSection" class="hidden">
                    <h3 style="color: #667eea; margin-bottom: 15px; font-size: 1.1em;">üì§ Your Token</h3>
                    <div class="section-content">
                        <div class="form-group">
                            <label>Parameter Token</label>
                            <div class="token-display" id="myToken"></div>
                            <div class="button-group" style="margin-top: 10px;">
                                <button class="copy-button" id="copyToken">Copy Token</button>
                                <button class="copy-button" id="copyLink">Copy Link</button>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>Direct Link</label>
                            <input type="text" id="shareLink" readonly style="font-size: 0.8em;">
                        </div>
                    </div>
                </div>

                <!-- Load Partner's Parameters -->
                <div>
                    <h3 style="color: #ffa726; margin-bottom: 15px; font-size: 1.1em;">üì• Partner's Token</h3>
                    <div class="section-content">
                        <div class="form-group">
                            <label>Partner's Parameter Token</label>
                            <textarea id="partnerToken" placeholder="Paste partner's token here..."></textarea>
                        </div>

                        <div class="button-group">
                            <button id="loadPartnerToken">Load Partner's Token</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 4: Key Generation (at bottom) -->
        <div class="section">
            <h2>üîë Key Generation</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <!-- Key Settings -->
                <div>
                    <h3 style="color: #667eea; margin-bottom: 15px; font-size: 1.1em;">Key Settings</h3>
                    <div class="section-content">
                        <div class="form-group">
                            <label>Elliptic Curve</label>
                            <select id="ecCurve">
                                <option value="P-256" selected>P-256 (Default)</option>
                                <option value="P-384">P-384</option>
                                <option value="P-521">P-521</option>
                            </select>
                        </div>

                        <div class="button-group">
                            <button id="generateKeypair">Generate New Keypair</button>
                        </div>
                    </div>
                </div>

                <!-- Key History -->
                <div>
                    <h3 style="color: #667eea; margin-bottom: 15px; font-size: 1.1em;">Key History</h3>
                    <div class="section-content">
                        <div id="keypairListContainer" class="hidden">
                            <div id="keypairList" class="keypair-list"></div>
                        </div>
                        <div id="noKeypairsMessage" class="alert alert-info">
                            No keypairs generated yet. Select a curve to auto-generate one.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // State Management
        // ========================================
        const state = {
            keypairs: [],
            activeKeypairId: null,
            partnerPublicKey: null,
            partnerPublicKeyRaw: null,
            partnerKeypairId: null,
            partnerCurve: null,
            myKeypairIdForPartner: null,
            constraints: null
        };

        const MAX_TOKEN_LENGTH = 8192;

        // ========================================
        // Utility Functions
        // ========================================
        function generateId(length = 8) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let id = '';
            const array = new Uint8Array(length);
            crypto.getRandomValues(array);
            for (let i = 0; i < length; i++) {
                id += chars[array[i] % chars.length];
            }
            return id;
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.length; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function getConstraints() {
            return {
                minLength: parseInt(document.getElementById('minLength').value),
                maxLength: parseInt(document.getElementById('maxLength').value),
                uppercase: document.getElementById('charUppercase').checked,
                lowercase: document.getElementById('charLowercase').checked,
                numbers: document.getElementById('charNumbers').checked,
                special: document.getElementById('charSpecial').checked,
                similar: document.getElementById('charSimilar').checked,
                whitespace: document.getElementById('charWhitespace').checked,
                diacritics: document.getElementById('charDiacritics').checked,
                emoji: document.getElementById('charEmoji').checked,
                excluded: document.getElementById('excludedChars').value
            };
        }

        function buildCharacterSet(constraints) {
            let charset = '';
            if (constraints.uppercase) charset += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            if (constraints.lowercase) charset += 'abcdefghijklmnopqrstuvwxyz';
            if (constraints.numbers) charset += '0123456789';
            if (constraints.special) charset += '!@#$%^&*()_+-=[]{}|;:,.<>?';
            if (constraints.whitespace) charset += ' \t';
            if (constraints.diacritics) charset += '√†√°√¢√§√®√©√™√´√¨√≠√Æ√Ø√≤√≥√¥√∂√π√∫√ª√º√ß√±√£√µ√Ä√Å√Ç√Ñ√à√â√ä√ã√å√ç√é√è√í√ì√î√ñ√ô√ö√õ√ú√á√ë√É√ï';
            if (constraints.emoji) {
              charset += 'üòÄüòÅüòÇüòÉüòÑüòÖüòÜüòáüòàüòâüòäüòãüòåüòçüòéüòèüòêüòëüòíüòìüòîüòïüòñüòóüòòüòôüòöüòõüòúüòùüòûüòüüò†üò°üò¢üò£üò§üò•üò¶üòßüò®üò©üò™üò´üò¨üò≠üòÆüòØüò∞üò±üò≤üò≥üò¥üòµüò∂üò∑üò∏üòπüò∫üòªüòºüòΩüòæüòøüôÄüôÅüôÇüôÉüôÑ';
              charset += 'üôÖüôÜüôáüôàüôâüôäüôãüôåüôçüôéüôè';
              charset += 'üöÄüöÅüöÇüöÉüöÑüöÖüöÜüöáüöàüöâüöäüöãüöåüöçüöéüöèüöêüöëüöíüöìüöîüöïüöñüöóüöòüöôüööüöõüöúüöùüöûüöüüö†üö°üö¢üö£üö§üö•üö¶üößüö®üö©üö™üö´üö¨üö≠üöÆüöØüö∞üö±üö≤üö≥üö¥üöµüö∂üö∑üö∏üöπüö∫üöªüöºüöΩüöæüöø';
              charset += 'üõÄüõÅüõÇüõÉüõÑüõÖ';
              charset += 'ü§êü§ëü§íü§ìü§îü§ïü§ñü§óü§òü§ôü§öü§õü§úü§ùü§ûü§üü§†ü§°ü§¢ü§£ü§§ü§•ü§¶ü§ßü§®ü§©ü§™ü§´ü§¨ü§≠ü§Æü§Øü§∞ü§±ü§≤ü§≥ü§¥ü§µü§∂ü§∑ü§∏ü§πü§∫ü§ºü§Ωü§æ';
              charset += 'ü•Äü•Åü•Çü•Éü•Ñü•Öü•áü•àü•âü•äü•ãü•åü•çü•éü•èü•êü•ëü•íü•ìü•îü•ïü•ñü•óü•òü•ôü•öü•õü•úü•ùü•ûü•üü•†ü•°ü•¢ü•£ü•§ü••ü•¶ü•ßü•®ü•©ü•™ü•´ü•¨ü•≠ü•Æü•Øü•∞ü•±ü•≥ü•¥ü•µü•∂ü•∫ü•ªü•ºü•Ωü•æü•ø';
              charset += 'ü¶Äü¶Åü¶Çü¶Éü¶Ñü¶Öü¶Üü¶áü¶àü¶âü¶äü¶ãü¶åü¶çü¶éü¶èü¶êü¶ëü¶íü¶ìü¶îü¶ïü¶ñü¶óü¶òü¶ôü¶öü¶õü¶úü¶ùü¶ûü¶üü¶†ü¶°ü¶¢ü¶∏ü¶πü¶∫ü¶ªü¶ºü¶Ωü¶æü¶ø';
              charset += 'üßÄüßÅüßÇüßêüßëüßíüßìüßîüßïüßñüßóüßòüßôüßöüßõüßúüßùüßûüßüüß†üß°üß¢üß£üß§üß•üß¶üßßüß®üß©üß™üß´üß¨üß≠üßÆüßØüß∞üß±üß≤üß≥üß¥üßµüß∂üß∑üß∏üßπüß∫üßªüßºüßΩüßæüßø';
              charset += 'üåÄüåÅüåÇüåÉüåÑüåÖüåÜüåáüåàüåâüåäüåãüååüåçüåéüåèüåêüåëüåíüåìüåîüåïüåñüåóüåòüåôüåöüåõüåúüåùüåûüåüüå†üå≠üåÆüåØüå∞üå±üå≤üå≥üå¥üåµüå∂üå∑üå∏üåπüå∫üåªüåºüåΩüåæüåøüçÄüçÅüçÇüçÉ';
              charset += 'üçÑüçÖüçÜüçáüçàüçâüçäüçãüçåüççüçéüçèüçêüçëüçíüçìüçîüçïüçñüçóüçòüçôüçöüçõüçúüçùüçûüçüüç†üç°üç¢üç£üç§üç•üç¶üçßüç®üç©üç™üç´üç¨üç≠üçÆüçØüç∞üç±üç≤üç≥üç¥üçµüç∂üç∑üç∏üçπüç∫üçªüçºüéÅüéÇüéÉüéÑüéÖüéÜüéáüéàüéâüéäüéãüéåüéçüééüéèüéêüéëüéíüéì';
              charset += 'üé†üé°üé¢üé£üé§üé•üé¶üéßüé®üé©üé™üé´üé¨üé≠üéÆüéØüé∞üé±üé≤üé≥üé¥üéµüé∂üé∑üé∏üéπüé∫üéªüéºüéΩüéæüéøüèÄüèÅüèÇüèÉüèÑüèÖüèÜüèáüèàüèâüèäüèãüèåüèèüèêüèëüèíüèìüè°üè¢üè£üè§üè•üè¶üèßüè®üè©üè™üè´üè¨üè≠üèÆüèØüè∞';
              charset += 'üêÄüêÅüêÇüêÉüêÑüêÖüêÜüêáüêàüêâüêäüêãüêåüêçüêéüêèüêêüêëüêíüêìüêîüêïüêñüêóüêòüêôüêöüêõüêúüêùüêûüêüüê†üê°üê¢üê£üê§üê•üê¶üêßüê®üê©üê™üê´üê¨üê≠üêÆüêØüê∞üê±üê≤üê≥üê¥üêµüê∂üê∑üê∏üêπüê∫üêªüêºüêΩüêæüêø';
              charset += 'üëÄüëÅüëÇüëÉüëÑüëÖüëÜüëáüëàüëâüëäüëãüëåüëçüëéüëèüëêüëëüëíüëìüëîüëïüëñüëóüëòüëôüëöüëõüëúüëùüëûüëüüë†üë°üë¢üë£üë§üë•üë¶üëßüë®üë©üë™üë´üë¨üë≠üëÆüëØüë∞üë±üë≤üë≥üë¥üëµüë∂üë∑üë∏üëπüë∫üëªüëºüëΩüëæüëøüíÄ';
              charset += 'üíÅüíÇüíÉüíÑüíÖüíÜüíáüíàüíâüíäüíãüíåüíçüíéüíèüíêüíëüííüíìüíîüíïüíñüíóüíòüíôüíöüíõüíúüíùüíûüíüüí†üí°üí¢üí£üí§üí•üí¶üíßüí®üí©üí™üí´üí¨üí≠üíÆüíØüí∞üí±üí≤üí≥üí¥üíµüí∂üí∑üí∏üíπüí∫üíªüíºüíΩüíæüíøüìÄüìÅüìÇüìÉüìÑüìÖüìÜüìáüìàüìâüìäüìãüìåüìçüìéüìè';
              charset += 'üìêüìëüìíüììüìîüìïüìñüìóüìòüìôüìöüìõüìúüìùüìûüìüüì†üì°üì¢üì£üì§üì•üì¶üìßüì®üì©üì™üì´üì¨üì≠üìÆüìØüì∞üì±üì≤üì≥üì¥üìµüì∂üì∑üì∏üìπüì∫üìªüìºüìΩüìøüîÄüîÅüîÇüîÉüîÑüîÖüîÜüîáüîàüîâüîäüîãüîåüîçüîéüîèüîêüîëüîíüîìüîîüîïüîñüîóüîòüîôüîöüîõüîúüîùüîûüîüüî†üî°üî¢üî£üî§';
              charset += 'üî•üî¶üîßüî®üî©üî™üî´üî¨üî≠üîÆüîØüî∞üî±üî≤üî≥üî¥üîµüî∂üî∑üî∏üîπüî∫üîªüîºüîΩüïåüïçüïéüïêüïëüïíüïìüïîüïïüïñüïóüïòüïôüïöüïõüïúüïùüïûüïüüï†üï°üï¢üï£üï§üï•üï¶üïß';
            }

            if (!constraints.similar) {
                charset = charset.replace(/[O0Il1|]/g, '');
            }

            if (constraints.excluded) {
                const excluded = constraints.excluded.split('');
                return Array.from(charset).filter(c => !excluded.includes(c));
            } else {
                return Array.from(charset);
            }
        }

        function copyToClipboard(text, buttonId) {
            navigator.clipboard.writeText(text).then(() => {
                const button = document.getElementById(buttonId);
                const originalText = button.textContent;
                button.textContent = '‚úì Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            });
        }

        function highlightCommonConstraints(mergedConstraints) {
            // Add highlighting to checkboxes that are active in merged constraints
            const checkboxes = ['charUppercase', 'charLowercase', 'charNumbers', 'charSpecial', 'charSimilar', 'charWhitespace', 'charDiacritics', 'charEmoji'];
            const constraintKeys = ['uppercase', 'lowercase', 'numbers', 'special', 'similar', 'whitespace', 'diacritics', 'emoji'];
            
            checkboxes.forEach((id, index) => {
                const checkbox = document.getElementById(id);
                const label = checkbox.parentElement;
                const key = constraintKeys[index];
                
                if (mergedConstraints[key]) {
                    // Highlight as common
                    label.style.backgroundColor = '#c8e6c9';
                    label.style.padding = '5px';
                    label.style.borderRadius = '4px';
                    label.style.fontWeight = 'bold';
                } else {
                    // Reset highlighting
                    label.style.backgroundColor = '';
                    label.style.padding = '';
                    label.style.borderRadius = '';
                    label.style.fontWeight = '';
                }
            });
        }

        // ========================================
        // Cryptographic Functions
        // ========================================
        async function generateKeypair(curveName) {
            const keypair = await crypto.subtle.generateKey(
                {
                    name: 'ECDH',
                    namedCurve: curveName
                },
                true,
                ['deriveBits']
            );

            const publicKeyRaw = await crypto.subtle.exportKey('raw', keypair.publicKey);
            const keypairId = generateId(6);

            const keypairData = {
                id: keypairId,
                curve: curveName,
                publicKey: keypair.publicKey,
                privateKey: keypair.privateKey,
                publicKeyRaw: publicKeyRaw,
                timestamp: Date.now()
            };

            state.keypairs.push(keypairData);
            state.activeKeypairId = keypairId;

            // Store in sessionStorage
            saveKeypairsToSession();

            return keypairData;
        }

        async function saveKeypairsToSession() {
            // Export keys as JWK for storage
            const sessionData = [];
            for (const kp of state.keypairs) {
                const publicKeyJWK = await crypto.subtle.exportKey('jwk', kp.publicKey);
                const privateKeyJWK = await crypto.subtle.exportKey('jwk', kp.privateKey);
                sessionData.push({
                    id: kp.id,
                    curve: kp.curve,
                    publicKeyRaw: arrayBufferToBase64(kp.publicKeyRaw),
                    publicKeyJWK: publicKeyJWK,
                    privateKeyJWK: privateKeyJWK,
                    timestamp: kp.timestamp
                });
            }
            sessionStorage.setItem('dhkex_keypairs', JSON.stringify(sessionData));
            sessionStorage.setItem('dhkex_active', state.activeKeypairId);
        }

        // ========================================
        // Persistent Storage (localStorage with optional encryption)
        // ========================================
        async function deriveKeyFromPassword(password, salt) {
            const encoder = new TextEncoder();
            const passwordKey = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveBits', 'deriveKey']
            );
            
            return await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                passwordKey,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }

        async function encryptData(data, password) {
            const encoder = new TextEncoder();
            const salt = crypto.getRandomValues(new Uint8Array(16));
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const key = await deriveKeyFromPassword(password, salt);
            
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                encoder.encode(JSON.stringify(data))
            );
            
            return {
                encrypted: arrayBufferToBase64(encrypted),
                salt: arrayBufferToBase64(salt),
                iv: arrayBufferToBase64(iv)
            };
        }

        async function decryptData(encryptedData, password) {
            const decoder = new TextDecoder();
            const salt = base64ToArrayBuffer(encryptedData.salt);
            const iv = base64ToArrayBuffer(encryptedData.iv);
            const key = await deriveKeyFromPassword(password, new Uint8Array(salt));
            
            try {
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: new Uint8Array(iv) },
                    key,
                    base64ToArrayBuffer(encryptedData.encrypted)
                );
                return JSON.parse(decoder.decode(decrypted));
            } catch (e) {
                throw new Error('Incorrect password or corrupted data');
            }
        }

        window.toggleStorageControls = function(keypairId) {
            const controls = document.getElementById(`storage-${keypairId}`);
            controls.classList.toggle('visible');
        };

        window.saveKeypairToPersistent = async function(keypairId) {
            const kp = state.keypairs.find(k => k.id === keypairId);
            if (!kp) return;
            
            const password = document.getElementById(`pwd-${keypairId}`).value;
            
            try {
                const publicKeyJWK = await crypto.subtle.exportKey('jwk', kp.publicKey);
                const privateKeyJWK = await crypto.subtle.exportKey('jwk', kp.privateKey);
                
                const keyData = {
                    id: kp.id,
                    curve: kp.curve,
                    publicKeyRaw: arrayBufferToBase64(kp.publicKeyRaw),
                    publicKeyJWK: publicKeyJWK,
                    privateKeyJWK: privateKeyJWK,
                    timestamp: kp.timestamp
                };
                
                let storageData;
                if (password) {
                    const encrypted = await encryptData(keyData, password);
                    storageData = {
                        encrypted: true,
                        data: encrypted
                    };
                } else {
                    storageData = {
                        encrypted: false,
                        data: keyData
                    };
                }
                
                const savedKeys = JSON.parse(localStorage.getItem('dhkex_persistent_keys') || '{}');
                savedKeys[keypairId] = storageData;
                localStorage.setItem('dhkex_persistent_keys', JSON.stringify(savedKeys));
                
                document.getElementById(`pwd-${keypairId}`).value = '';
                updateKeypairList();
                showToast('Keypair saved to persistent storage!', 'success');
            } catch (e) {
                showToast('Error saving keypair: ' + e.message, 'error');
            }
        };

        window.deleteKeypairFromPersistent = function(keypairId) {
            showConfirm('Remove this keypair from persistent storage?', () => {
                const savedKeys = JSON.parse(localStorage.getItem('dhkex_persistent_keys') || '{}');
                delete savedKeys[keypairId];
                localStorage.setItem('dhkex_persistent_keys', JSON.stringify(savedKeys));
                updateKeypairList();
                showToast('Keypair removed from storage', 'info');
            });
        };

        async function loadPersistentKeypairs() {
            try {
                const savedKeys = JSON.parse(localStorage.getItem('dhkex_persistent_keys') || '{}');
                
                for (const [keypairId, storageData] of Object.entries(savedKeys)) {
                    // Skip if already loaded in session
                    if (state.keypairs.find(k => k.id === keypairId)) continue;
                    
                    let keyData;
                    
                    if (storageData.encrypted) {
                        // Skip encrypted keys - user must manually load them
                        continue;
                    } else {
                        keyData = storageData.data;
                    }
                    
                    // Import the keys
                    const publicKey = await crypto.subtle.importKey(
                        'jwk',
                        keyData.publicKeyJWK,
                        { name: 'ECDH', namedCurve: keyData.curve },
                        true,
                        []
                    );
                    
                    const privateKey = await crypto.subtle.importKey(
                        'jwk',
                        keyData.privateKeyJWK,
                        { name: 'ECDH', namedCurve: keyData.curve },
                        true,
                        ['deriveBits']
                    );
                    
                    const publicKeyRaw = base64ToArrayBuffer(keyData.publicKeyRaw);
                    
                    state.keypairs.push({
                        id: keyData.id,
                        curve: keyData.curve,
                        publicKey: publicKey,
                        privateKey: privateKey,
                        publicKeyRaw: publicKeyRaw,
                        timestamp: keyData.timestamp
                    });
                }
                
                if (state.keypairs.length > 0 && !state.activeKeypairId) {
                    state.activeKeypairId = state.keypairs[state.keypairs.length - 1].id;
                }
            } catch (e) {
                console.error('Error loading persistent keypairs:', e);
            }
        }

        async function deriveSharedSecret(privateKey, publicKey, curveName, infoBytes, saltBytes, curveBits, bits = 256) {
            const sharedSecret = await crypto.subtle.deriveBits(
                {
                    name: 'ECDH',
                    public: publicKey
                },
                privateKey,
                curveBits
            );
            const result = await crypto.subtle.deriveBits(
                {
                    name: 'HKDF',
                    hash: 'SHA-256',
                    salt: saltBytes || new Uint8Array([]),
                    info: infoBytes || new Uint8Array([])
                },
                await crypto.subtle.importKey('raw', sharedSecret, { name: 'HKDF' }, false, ['deriveBits']),
                bits
            );
            return new Uint8Array(result);
        }

        function getDeterministicConstraints(constraints) {
            return {
                minLength: constraints.minLength,
                maxLength: constraints.maxLength,
                uppercase: constraints.uppercase,
                lowercase: constraints.lowercase,
                numbers: constraints.numbers,
                special: constraints.special,
                similar: constraints.similar,
                whitespace: constraints.whitespace,
                diacritics: constraints.diacritics,
                emoji: constraints.emoji,
                excluded: constraints.excluded
            };
        }

        function buildConstraintsInfoBytes(constraints) {
            const deterministic = getDeterministicConstraints(constraints);
            const encoder = new TextEncoder();
            return encoder.encode(JSON.stringify(deterministic));
        }

        function xorStringsToBytes(a, b) {
            if (!a || !b) {
                return new Uint8Array([]);
            }
            const encoder = new TextEncoder();
            const aBytes = encoder.encode(a);
            const bBytes = encoder.encode(b);
            const maxLen = Math.max(aBytes.length, bBytes.length);
            const result = new Uint8Array(maxLen);
            for (let i = 0; i < maxLen; i++) {
                const aByte = i < aBytes.length ? aBytes[i] : 0;
                const bByte = i < bBytes.length ? bBytes[i] : 0;
                result[i] = aByte ^ bByte;
            }
            return result;
        }

        async function deriveHkdfSaltFromKeyIds(myKeypairId, partnerKeypairId, bits = 256) {
            if (!myKeypairId || !partnerKeypairId) {
                return new Uint8Array([]);
            }
            const xorBytes = xorStringsToBytes(myKeypairId, partnerKeypairId);
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                xorBytes,
                { name: 'PBKDF2' },
                false,
                ['deriveBits']
            );
            const salt = new TextEncoder().encode('dhkex-keyid-salt');
            const derived = await crypto.subtle.deriveBits(
                {
                    name: 'PBKDF2',
                    hash: 'SHA-256',
                    salt,
                    iterations: 10000
                },
                keyMaterial,
                bits
            );
            return new Uint8Array(derived);
        }

        function generateVerificationToken(myPublicKeyRaw, partnerPublicKeyRaw, constraints, bits = 24) {
            const myBytes = new Uint8Array(myPublicKeyRaw);
            const partnerBytes = new Uint8Array(partnerPublicKeyRaw);

            // XOR the public keys
            const maxLen = Math.max(myBytes.length, partnerBytes.length);
            const xorResult = new Uint8Array(maxLen);
            
            for (let i = 0; i < maxLen; i++) {
                const myByte = i < myBytes.length ? myBytes[i] : 0;
                const partnerByte = i < partnerBytes.length ? partnerBytes[i] : 0;
                xorResult[i] = myByte ^ partnerByte;
            }

            // Incorporate constraints into the verification token
            // Serialize constraints to bytes
            const constraintsBytes = buildConstraintsInfoBytes(constraints);

            // XOR constraints into the result
            for (let i = 0; i < constraintsBytes.length; i++) {
                xorResult[i % xorResult.length] ^= constraintsBytes[i];
            }

            // Divide into blocks and XOR them together
            const blockSize = Math.ceil(bits / 8);
            let finalBlock = new Uint8Array(blockSize);
            
            for (let i = 0; i < xorResult.length; i++) {
                finalBlock[i % blockSize] ^= xorResult[i];
            }

            // Convert to hex string (limited to requested bits)
            let hexString = '';
            const numBytes = Math.ceil(bits / 8);
            for (let i = 0; i < numBytes; i++) {
                hexString += finalBlock[i].toString(16).padStart(2, '0');
            }

            // Trim to exact bit count
            const hexChars = Math.ceil(bits / 4);
            return hexString.substring(0, hexChars).toUpperCase();
        }

        function derivePassword(sharedSecret, charset, targetLength) {
            if (charset.length === 0) {
                throw new Error('No character set selected');
            }

            // Use the shared secret to generate a password
            // We'll use the bytes of the shared secret to index into the charset
            let password = '';
            let byteOffset = 0;

            for (let i = 0; i < targetLength; i++) {
                // Use each byte to select a character from the charset
                // For better distribution, we'll use multiple bytes if charset is large
                let index;
                if (charset.length <= 256) {
                    index = sharedSecret[byteOffset] % charset.length;
                    byteOffset++;
                } else {
                    // Use two bytes for larger charsets
                    const byte1 = sharedSecret[byteOffset];
                    const byte2 = sharedSecret[byteOffset + 1];
                    index = ((byte1 << 8) | byte2) % charset.length;
                    byteOffset += 2;
                }
                password += charset[index];
            }

            return password;
        }

        // ========================================
        // Token Management (TLV Encoding)
        // ========================================
        // TLV Tags:
        // 0x01: Keypair ID (string)
        // 0x02: Public Key (binary)
        // 0x03: Curve (1 byte: 0=P-256, 1=P-384, 2=P-521)
        // 0x04: Min Length (1 byte)
        // 0x05: Max Length (1 byte)
        // 0x06: Charset Flags (variable length, bit-packed)
        //       Byte 0: bit 0=uppercase, 1=lowercase, 2=numbers, 3=special, 4=similar, 5=whitespace, 6=diacritics, 7=emoji
        // 0x07: Excluded chars (string)
        // 0x08: Partner Keypair ID (string) - ID of the keypair that should be used to respond

        function encodeTLV(tag, value) {
            let valueBytes;
            
            if (typeof value === 'string') {
                const encoder = new TextEncoder();
                valueBytes = encoder.encode(value);
            } else if (typeof value === 'number') {
                valueBytes = new Uint8Array([value]);
            } else if (value instanceof ArrayBuffer || value instanceof Uint8Array) {
                valueBytes = new Uint8Array(value);
            } else {
                throw new Error('Unsupported value type for TLV encoding');
            }

            const length = valueBytes.length;
            let result;

            if (length < 128) {
                // Short form: 1 byte length
                result = new Uint8Array(2 + length);
                result[0] = tag;
                result[1] = length;
                result.set(valueBytes, 2);
            } else {
                // Long form: 2 bytes length (supports up to 65535)
                result = new Uint8Array(4 + length);
                result[0] = tag;
                result[1] = 0x80 | 0x02; // Length is encoded in next 2 bytes
                result[2] = (length >> 8) & 0xFF;
                result[3] = length & 0xFF;
                result.set(valueBytes, 4);
            }

            return result;
        }

        function decodeTLV(buffer, offset) {
            const view = new Uint8Array(buffer);
            
            if (offset >= view.length) {
                return null;
            }

            const tag = view[offset];
            let length;
            let valueOffset;

            if (view[offset + 1] & 0x80) {
                // Long form
                const lengthBytes = view[offset + 1] & 0x7F;
                if (lengthBytes === 2) {
                    length = (view[offset + 2] << 8) | view[offset + 3];
                    valueOffset = offset + 4;
                } else {
                    throw new Error('Unsupported length encoding');
                }
            } else {
                // Short form
                length = view[offset + 1];
                valueOffset = offset + 2;
            }

            const value = view.slice(valueOffset, valueOffset + length);
            const nextOffset = valueOffset + length;

            return { tag, value, nextOffset };
        }

        function createToken(keypairId, publicKeyRaw, curve, constraints, partnerKeypairId = null) {
            const parts = [];

            // Tag 0x01: Keypair ID
            parts.push(encodeTLV(0x01, keypairId));

            // Tag 0x02: Public Key
            parts.push(encodeTLV(0x02, publicKeyRaw));

            // Tag 0x03: Curve (encode as number)
            const curveMap = { 'P-256': 0, 'P-384': 1, 'P-521': 2 };
            parts.push(encodeTLV(0x03, curveMap[curve] || 0));

            // Tag 0x04: Min Length
            parts.push(encodeTLV(0x04, constraints.minLength));

            // Tag 0x05: Max Length
            parts.push(encodeTLV(0x05, constraints.maxLength));

            // Tag 0x06: Charset Flags (multi-byte support)
            let flags = 0;
            if (constraints.uppercase) flags |= 0x01;
            if (constraints.lowercase) flags |= 0x02;
            if (constraints.numbers) flags |= 0x04;
            if (constraints.special) flags |= 0x08;
            if (constraints.similar) flags |= 0x10;
            if (constraints.whitespace) flags |= 0x20;
            if (constraints.diacritics) flags |= 0x40;
            if (constraints.emoji) flags |= 0x80;
            
            // Only add if flags is non-zero
            if (flags !== 0) {
                parts.push(encodeTLV(0x06, flags));
            }

            // Tag 0x07: Excluded chars (only if non-empty)
            if (constraints.excluded) {
                parts.push(encodeTLV(0x07, constraints.excluded));
            }

            // Tag 0x08: Partner Keypair ID (only if provided)
            if (partnerKeypairId) {
                parts.push(encodeTLV(0x08, partnerKeypairId));
            }

            // Concatenate all parts
            const totalLength = parts.reduce((sum, part) => sum + part.length, 0);
            const result = new Uint8Array(totalLength);
            let offset = 0;
            for (const part of parts) {
                result.set(part, offset);
                offset += part.length;
            }

            // Base64 encode the binary TLV data
            return arrayBufferToBase64(result.buffer);
        }

        function parseToken(tokenString) {
            try {
                if (!tokenString || tokenString.length > MAX_TOKEN_LENGTH) {
                    return null;
                }
                const buffer = base64ToArrayBuffer(tokenString);
                const result = {
                    keypairId: null,
                    publicKeyRaw: null,
                    curve: null,
                    partnerKeypairId: null,
                    constraints: {
                        minLength: 16,
                        maxLength: 32,
                        uppercase: true,
                        lowercase: true,
                        numbers: true,
                        special: true,
                        similar: true,
                        whitespace: false,
                        diacritics: false,
                        emoji: false,
                        excluded: ''
                    }
                };

                const curveMap = ['P-256', 'P-384', 'P-521'];
                let offset = 0;

                while (offset < buffer.byteLength) {
                    const tlv = decodeTLV(buffer, offset);
                    if (!tlv) break;

                    const decoder = new TextDecoder();

                    switch (tlv.tag) {
                        case 0x01: // Keypair ID
                            result.keypairId = decoder.decode(tlv.value);
                            break;
                        case 0x02: // Public Key
                            result.publicKeyRaw = tlv.value.buffer;
                            break;
                        case 0x03: // Curve
                            result.curve = curveMap[tlv.value[0]] || 'P-256';
                            break;
                        case 0x04: // Min Length
                            result.constraints.minLength = tlv.value[0];
                            break;
                        case 0x05: // Max Length
                            result.constraints.maxLength = tlv.value[0];
                            break;
                        case 0x06: // Charset Flags
                            const flags = tlv.value[0];
                            result.constraints.uppercase = !!(flags & 0x01);
                            result.constraints.lowercase = !!(flags & 0x02);
                            result.constraints.numbers = !!(flags & 0x04);
                            result.constraints.special = !!(flags & 0x08);
                            result.constraints.similar = !!(flags & 0x10);
                            result.constraints.whitespace = !!(flags & 0x20);
                            result.constraints.diacritics = !!(flags & 0x40);
                            result.constraints.emoji = !!(flags & 0x80);
                            break;
                        case 0x07: // Excluded chars
                            result.constraints.excluded = decoder.decode(tlv.value);
                            break;
                        case 0x08: // Partner Keypair ID
                            result.partnerKeypairId = decoder.decode(tlv.value);
                            break;
                    }

                    offset = tlv.nextOffset;
                }

                return result;
            } catch (e) {
                console.error('Failed to parse token:', e);
                return null;
            }
        }

        // ========================================
        // Intelligent Key Management
        // ========================================
        async function ensureKeypairForCurve(curveName) {
            // Find the latest keypair for this curve
            const matchingKeys = state.keypairs.filter(kp => kp.curve === curveName);
            
            if (matchingKeys.length > 0) {
                // Sort by timestamp, newest first
                matchingKeys.sort((a, b) => b.timestamp - a.timestamp);
                const latestKey = matchingKeys[0];
                state.activeKeypairId = latestKey.id;
                updateKeypairList();
                updateShareSection();
                return latestKey;
            } else {
                // No matching keypair, generate one
                console.log('Auto-generating keypair for curve: ' + curveName);
                const newKeypair = await generateKeypair(curveName);
                updateKeypairList();
                updateShareSection();
                return newKeypair;
            }
        }

        // ========================================
        // DOM Helper Functions
        // ========================================
        function createParagraphWithLabel(labelText, valueText) {
            const p = document.createElement('p');
            p.style.marginBottom = '10px';
            const strong = document.createElement('strong');
            strong.textContent = labelText;
            p.appendChild(strong);
            p.appendChild(document.createTextNode(' ' + valueText));
            return p;
        }

        function createConstraintGrid(constraints) {
            const grid = document.createElement('div');
            grid.style.marginTop = '10px';
            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = '1fr 1fr';
            grid.style.gap = '5px';

            const addRow = (label, value) => {
                const row = document.createElement('div');
                row.textContent = label + ': ' + (value ? '‚úì' : '‚úó');
                grid.appendChild(row);
            };

            addRow('üî§ Uppercase', constraints.uppercase);
            addRow('üî° Lowercase', constraints.lowercase);
            addRow('üî¢ Numbers', constraints.numbers);
            addRow('üî£ Special', constraints.special);
            addRow('üëÅÔ∏è Similar', constraints.similar);
            addRow('‚ê£ Whitespace', constraints.whitespace);
            addRow('√© Diacritics', constraints.diacritics);
            addRow('üòÄ Emoji', constraints.emoji);

            if (constraints.excluded) {
                const excludedRow = document.createElement('div');
                excludedRow.style.gridColumn = '1 / -1';
                excludedRow.textContent = 'üö´ Excluded: ' + constraints.excluded;
                grid.appendChild(excludedRow);
            }

            return grid;
        }

        function showPartnerConstraints(parsed) {
            const partnerPanel = document.getElementById('partnerConstraintsContent');
            partnerPanel.textContent = '';
            
            const wrapper = document.createElement('div');
            wrapper.style.padding = '10px';
            wrapper.style.background = 'white';
            wrapper.style.borderRadius = '6px';

            wrapper.appendChild(createParagraphWithLabel('üÜî Keypair ID:', parsed.keypairId));
            wrapper.appendChild(createParagraphWithLabel('üìê Curve:', parsed.curve));
            wrapper.appendChild(createParagraphWithLabel('üìè Length:', parsed.constraints.minLength + '-' + parsed.constraints.maxLength + ' chars'));
            wrapper.appendChild(createConstraintGrid(parsed.constraints));
            
            partnerPanel.appendChild(wrapper);
        }

        function showMissingKeypairError(partnerKeypairId) {
            const partnerPanel = document.getElementById('partnerConstraintsContent');
            partnerPanel.textContent = '';

            const alert = document.createElement('div');
            alert.className = 'alert';
            alert.style.background = '#ffebee';
            alert.style.border = '1px solid #ef5350';
            alert.style.color = '#c62828';

            const title = document.createElement('strong');
            title.textContent = '‚ö†Ô∏è Error: Missing Keypair';
            alert.appendChild(title);
            alert.appendChild(document.createElement('br'));

            const line1 = document.createElement('span');
            line1.textContent = 'Partner requested keypair ID ';
            alert.appendChild(line1);

            const idStrong = document.createElement('strong');
            idStrong.textContent = partnerKeypairId;
            alert.appendChild(idStrong);
            alert.appendChild(document.createTextNode(' but it was not found in your key history.'));
            alert.appendChild(document.createElement('br'));

            const line2 = document.createElement('span');
            line2.textContent = 'This token was meant as a response to a specific keypair you previously shared.';
            alert.appendChild(line2);

            partnerPanel.appendChild(alert);
        }

        // ========================================
        // UI Update Functions
        // ========================================
        function updateKeypairList() {
            const container = document.getElementById('keypairListContainer');
            const list = document.getElementById('keypairList');
            const noKeysMsg = document.getElementById('noKeypairsMessage');

            if (state.keypairs.length === 0) {
                container.classList.add('hidden');
                noKeysMsg.classList.remove('hidden');
                return;
            }

            container.classList.remove('hidden');
            noKeysMsg.classList.add('hidden');
            list.innerHTML = '';

            state.keypairs.forEach(kp => {
                const item = document.createElement('div');
                item.className = 'keypair-item' + (kp.id === state.activeKeypairId ? ' active' : '');
                const timestamp = new Date(kp.timestamp).toLocaleString();
                
                // Check if this key is saved in localStorage
                const savedKeys = JSON.parse(localStorage.getItem('dhkex_persistent_keys') || '{}');
                const isSaved = savedKeys.hasOwnProperty(kp.id);
                const isEncrypted = isSaved && savedKeys[kp.id].encrypted;
                
                item.innerHTML = `
                    <div class="keypair-item-header">
                        <div class="keypair-info">
                            <span class="keypair-id">ID: ${kp.id}</span>
                            <span class="keypair-curve">Curve: ${kp.curve}</span>
                            <span class="keypair-curve">Created: ${timestamp}</span>
                        </div>
                        <div class="keypair-actions">
                            <button class="icon-button ${isSaved ? 'saved' : ''}" 
                                    onclick="toggleStorageControls('${kp.id}')" 
                                    title="${isSaved ? (isEncrypted ? 'Saved with password' : 'Saved') : 'Save to persistent storage'}">
                                ${isEncrypted ? 'üîí' : (isSaved ? 'üíæ' : 'üíæ')}
                            </button>
                            <button class="copy-button" onclick="setActiveKeypair('${kp.id}')">
                                ${kp.id === state.activeKeypairId ? 'Active' : 'Select'}
                            </button>
                        </div>
                    </div>
                    <div id="storage-${kp.id}" class="keypair-storage-controls">
                        <div class="storage-input-group">
                            <input type="password" 
                                   id="pwd-${kp.id}" 
                                   placeholder="Password (optional)" />
                            <button onclick="saveKeypairToPersistent('${kp.id}')">
                                ${isSaved ? 'Update' : 'Save'}
                            </button>
                            ${isSaved ? `<button onclick="deleteKeypairFromPersistent('${kp.id}')">Delete</button>` : ''}
                        </div>
                        <div class="storage-hint">
                            ${isSaved ? 'Saved in browser storage' : 'Leave password blank for unencrypted storage'}
                        </div>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        function updateShareSection() {
            const activeKeypair = state.keypairs.find(kp => kp.id === state.activeKeypairId);
            if (!activeKeypair) {
                document.getElementById('shareSection').classList.add('hidden');
                return;
            }

            const constraints = getConstraints();
            const token = createToken(
                activeKeypair.id,
                activeKeypair.publicKeyRaw,
                activeKeypair.curve,
                constraints,
                state.myKeypairIdForPartner
            );

            document.getElementById('myToken').textContent = token;
            
            const baseUrl = window.location.href.split('#')[0].split('?')[0];
            const link = baseUrl + '#token=' + encodeURIComponent(token);
            document.getElementById('shareLink').value = link;

            document.getElementById('shareSection').classList.remove('hidden');
        }

        async function processPartnerToken(tokenString) {
            const parsed = parseToken(tokenString);
            if (!parsed) {
                showToast('Invalid token format', 'error');
                return;
            }

            // Import the partner's public key
            const partnerPublicKey = await crypto.subtle.importKey(
                'raw',
                parsed.publicKeyRaw,
                {
                    name: 'ECDH',
                    namedCurve: parsed.curve
                },
                false,
                []
            );

            state.partnerPublicKey = partnerPublicKey;
            state.partnerPublicKeyRaw = parsed.publicKeyRaw;
            state.partnerKeypairId = parsed.keypairId;
            state.partnerCurve = parsed.curve;
            
            // If partner specified which keypair we should use, check if we have it
            if (parsed.partnerKeypairId) {
                const targetKeypair = state.keypairs.find(kp => kp.id === parsed.partnerKeypairId);
                if (targetKeypair) {
                    state.activeKeypairId = parsed.partnerKeypairId;
                    updateKeypairList(); // Update UI to show active keypair
                } else {
                    // Show error - we don't have the requested keypair
                    showMissingKeypairError(parsed.partnerKeypairId);
                    return; // Don't proceed with password generation
                }
            }
            
            // Store partner's keypair ID so our response token includes it
            state.myKeypairIdForPartner = parsed.keypairId;
            
            // Merge constraints (take the most restrictive)
            const currentConstraints = getConstraints();
            state.constraints = {
                minLength: Math.max(parsed.constraints.minLength, currentConstraints.minLength),
                maxLength: Math.min(parsed.constraints.maxLength, currentConstraints.maxLength),
                uppercase: parsed.constraints.uppercase && currentConstraints.uppercase,
                lowercase: parsed.constraints.lowercase && currentConstraints.lowercase,
                numbers: parsed.constraints.numbers && currentConstraints.numbers,
                special: parsed.constraints.special && currentConstraints.special,
                similar: parsed.constraints.similar && currentConstraints.similar,
                whitespace: parsed.constraints.whitespace && currentConstraints.whitespace,
                diacritics: parsed.constraints.diacritics && currentConstraints.diacritics,
                emoji: parsed.constraints.emoji && currentConstraints.emoji,
                excluded: (parsed.constraints.excluded + currentConstraints.excluded).split('').filter((v, i, a) => a.indexOf(v) === i).join('')
            };

            // Show partner constraints in the side panel
            showPartnerConstraints(parsed);
            
            // Highlight common constraints
            highlightCommonConstraints(state.constraints);

            // Update our share section to include partner's keypair ID in our token
            updateShareSection();

            // If we have an active keypair, derive the password
            if (state.activeKeypairId) {
                await deriveAndDisplayPassword();
            }
        }

        async function deriveAndDisplayPassword() {
            const activeKeypair = state.keypairs.find(kp => kp.id === state.activeKeypairId);
            if (!activeKeypair || !state.partnerPublicKey) {
                return;
            }

            // Check curve compatibility
            if (activeKeypair.curve !== state.partnerCurve) {
                showToast('Curve mismatch! You are using ' + activeKeypair.curve + ' but partner is using ' + state.partnerCurve, 'error', 6000);
                return;
            }

            // Build character set and calculate bytes needed
            const charset = buildCharacterSet(state.constraints);
            const targetLength = Math.min(state.constraints.maxLength, Math.floor((state.constraints.minLength + state.constraints.maxLength) / 2));
            const bytesPerChar = charset.length <= 256 ? 1 : 2;
            const bitsNeeded = targetLength * bytesPerChar * 8;

            // Derive shared secret with exactly the number of bits we need
            const curveBits = activeKeypair.curve === 'P-384' ? 384 : (activeKeypair.curve === 'P-521' ? 521 : 256);
            const infoBytes = buildConstraintsInfoBytes(state.constraints);
            const saltBytes = await deriveHkdfSaltFromKeyIds(activeKeypair.id, state.partnerKeypairId, curveBits);
            const sharedSecret = await deriveSharedSecret(
                activeKeypair.privateKey,
                state.partnerPublicKey,
                activeKeypair.curve,
                infoBytes,
                saltBytes,
                curveBits,
                bitsNeeded
            );

            // Generate password
            const password = derivePassword(sharedSecret, charset, targetLength);

            // Generate verification token
            const verificationToken = generateVerificationToken(activeKeypair.publicKeyRaw, state.partnerPublicKeyRaw, state.constraints, 24);

            // Display results
            document.getElementById('sharedPassword').textContent = password;
            document.getElementById('verificationToken').textContent = verificationToken;
            document.getElementById('resultsSection').classList.remove('hidden');
        }

        // ========================================
        // Global Functions (for onclick handlers)
        // ========================================
        window.setActiveKeypair = function(keypairId) {
            state.activeKeypairId = keypairId;
            saveKeypairsToSession();
            updateKeypairList();
            updateShareSection();
        };

        // ========================================
        // Event Handlers
        // ========================================
        document.getElementById('generateKeypair').addEventListener('click', async function() {
            const curve = document.getElementById('ecCurve').value;
            const button = this;
            button.disabled = true;
            button.textContent = 'Generating...';

            try {
                await generateKeypair(curve);
                updateKeypairList();
                updateShareSection();
            } catch (e) {
                showToast('Failed to generate keypair: ' + e.message, 'error');
            } finally {
                button.disabled = false;
                button.textContent = 'Generate New Keypair';
            }
        });

        // Auto-select or generate keypair when curve changes
        document.getElementById('ecCurve').addEventListener('change', async function() {
            const curve = this.value;
            await ensureKeypairForCurve(curve);
        });

        document.getElementById('copyToken').addEventListener('click', function() {
            const token = document.getElementById('myToken').textContent;
            copyToClipboard(token, 'copyToken');
        });

        document.getElementById('copyLink').addEventListener('click', function() {
            const link = document.getElementById('shareLink').value;
            copyToClipboard(link, 'copyLink');
        });

        document.getElementById('loadPartnerToken').addEventListener('click', async function() {
            await loadPartnerTokenFromTextarea();
        });

        // Auto-import partner tokens when pasted
        let partnerTokenTimeout;
        document.getElementById('partnerToken').addEventListener('input', function() {
            clearTimeout(partnerTokenTimeout);
            partnerTokenTimeout = setTimeout(async () => {
                const tokenString = this.value.trim();
                if (tokenString && tokenString.length > 20) { // Basic validation
                    try {
                        // Try to parse to see if it's valid
                        const parsed = parseToken(tokenString);
                        if (parsed && parsed.publicKeyRaw) {
                            console.log('Auto-importing partner token...');
                            await loadPartnerTokenFromTextarea();
                        }
                    } catch (e) {
                        // Invalid token, don't auto-import
                    }
                }
            }, 500); // Wait 500ms after user stops typing
        });

        async function loadPartnerTokenFromTextarea() {
            const tokenString = document.getElementById('partnerToken').value.trim();
            if (!tokenString) {
                showToast('Please paste a token first', 'warning');
                return;
            }

            const button = document.getElementById('loadPartnerToken');
            button.disabled = true;
            button.textContent = 'Loading...';

            try {
                await processPartnerToken(tokenString);
            } catch (e) {
                showToast('Failed to process token: ' + e.message, 'error');
            } finally {
                button.disabled = false;
                button.textContent = "Load Partner's Token";
            }
        }

        document.getElementById('copyPassword').addEventListener('click', function() {
            const password = document.getElementById('sharedPassword').textContent;
            copyToClipboard(password, 'copyPassword');
        });

        document.getElementById('copyVerification').addEventListener('click', function() {
            const token = document.getElementById('verificationToken').textContent;
            copyToClipboard(token, 'copyVerification');
        });

        // Update share section when constraints change
        ['minLength', 'maxLength', 'charUppercase', 'charLowercase', 'charNumbers', 'charSpecial', 'charSimilar', 'charWhitespace', 'charDiacritics', 'charEmoji', 'excludedChars'].forEach(id => {
            const element = document.getElementById(id);
            element.addEventListener('change', async function() {
                if (state.activeKeypairId) {
                    updateShareSection();
                    if (state.partnerPublicKey) {
                        await processPartnerToken(document.getElementById('partnerToken').value.trim());
                    }
                }
            });
        });

        // ========================================
        // Session Storage Restoration
        // ========================================
        async function restoreKeypairsFromSession() {
            try {
                const savedKeypairs = sessionStorage.getItem('dhkex_keypairs');
                const savedActive = sessionStorage.getItem('dhkex_active');
                
                if (savedKeypairs) {
                    const sessionData = JSON.parse(savedKeypairs);
                    
                    for (const data of sessionData) {
                        // Import keys from JWK
                        const publicKey = await crypto.subtle.importKey(
                            'jwk',
                            data.publicKeyJWK,
                            { name: 'ECDH', namedCurve: data.curve },
                            true,
                            []
                        );
                        
                        const privateKey = await crypto.subtle.importKey(
                            'jwk',
                            data.privateKeyJWK,
                            { name: 'ECDH', namedCurve: data.curve },
                            true,
                            ['deriveBits']
                        );
                        
                        const keypairData = {
                            id: data.id,
                            curve: data.curve,
                            publicKey: publicKey,
                            privateKey: privateKey,
                            publicKeyRaw: base64ToArrayBuffer(data.publicKeyRaw),
                            timestamp: data.timestamp
                        };
                        
                        state.keypairs.push(keypairData);
                    }
                    
                    if (savedActive) {
                        state.activeKeypairId = savedActive;
                    }
                    
                    updateKeypairList();
                    if (state.activeKeypairId) {
                        updateShareSection();
                    }
                    
                    console.log('Restored ' + state.keypairs.length + ' keypair(s) from session');
                }
            } catch (e) {
                console.error('Failed to restore session:', e);
            }
        }

        // ========================================
        // Initialization
        // ========================================
        window.addEventListener('DOMContentLoaded', async function() {
            // Load persistent keypairs from localStorage (unencrypted only)
            await loadPersistentKeypairs();
            
            // Restore keypairs from session storage
            await restoreKeypairsFromSession();

            // Check for token in URL fragment or query and show welcome banner if appropriate
            const hashParams = new URLSearchParams(window.location.hash.startsWith('#') ? window.location.hash.slice(1) : '');
            const urlParams = new URLSearchParams(window.location.search);
            const tokenParam = hashParams.get('token') || hashParams.get('t') || urlParams.get('token') || urlParams.get('t');
            
            if (tokenParam) {
                // Show welcome banner if not previously dismissed
                if (!sessionStorage.getItem('welcomeBannerDismissed')) {
                    document.getElementById('welcomeWrapper').classList.remove('hidden');
                }
                
                // Auto-fill the partner token field
                const partnerTokenField = document.getElementById('partnerToken');
                if (partnerTokenField && !partnerTokenField.value) {
                    partnerTokenField.value = tokenParam;
                    // Trigger auto-import
                    partnerTokenField.dispatchEvent(new Event('input'));
                }
            }

            // Ensure we have a keypair for the default curve
            const defaultCurve = document.getElementById('ecCurve').value;
            await ensureKeypairForCurve(defaultCurve);
        });

        // ========================================
        // Help Modal Functions
        // ========================================
        function openHelpModal() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelpModal() {
            document.getElementById('helpModal').classList.remove('active');
        }

        function closeHelpModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeHelpModal();
            }
        }

        function closeWelcomeBanner() {
            document.getElementById('welcomeWrapper').classList.add('hidden');
            sessionStorage.setItem('welcomeBannerDismissed', 'true');
        }

        // ========================================
        // Toast Notification System
        // ========================================
        function showToast(message, type = 'info', duration = 4000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = {
                success: '‚úì',
                error: '‚úï',
                warning: '‚ö†',
                info: '‚Ñπ'
            };
            
            toast.innerHTML = `
                <div class="toast-icon">${icons[type] || icons.info}</div>
                <div class="toast-message">${message}</div>
                <button class="toast-close" onclick="closeToast(this)">&times;</button>
            `;
            
            container.appendChild(toast);
            
            if (duration > 0) {
                setTimeout(() => {
                    closeToast(toast.querySelector('.toast-close'));
                }, duration);
            }
        }

        function closeToast(button) {
            const toast = button.parentElement;
            toast.classList.add('removing');
            setTimeout(() => {
                toast.remove();
            }, 300);
        }

        window.showConfirm = function(message, onConfirm, title = 'Confirm Action') {
            const overlay = document.getElementById('confirmOverlay');
            const messageEl = document.getElementById('confirmMessage');
            const titleEl = document.getElementById('confirmTitle');
            
            messageEl.textContent = message;
            titleEl.textContent = title;
            overlay.classList.add('active');
            
            // Store callback for when user confirms
            window._confirmCallback = onConfirm;
        };

        window.closeConfirm = function(confirmed) {
            const overlay = document.getElementById('confirmOverlay');
            overlay.classList.remove('active');
            
            if (confirmed && window._confirmCallback) {
                window._confirmCallback();
            }
            
            window._confirmCallback = null;
        };

        // Close confirm on overlay click
        document.getElementById('confirmOverlay')?.addEventListener('click', function(event) {
            if (event.target === this) {
                closeConfirm(false);
            }
        });
    </script>

    <!-- Confirmation Modal -->
    <div id="confirmOverlay" class="confirm-overlay">
        <div class="confirm-dialog">
            <div class="confirm-header">
                <h3 id="confirmTitle">Confirm Action</h3>
            </div>
            <div class="confirm-body">
                <p id="confirmMessage"></p>
            </div>
            <div class="confirm-footer">
                <button class="confirm-cancel" onclick="closeConfirm(false)">Cancel</button>
                <button class="confirm-confirm" onclick="closeConfirm(true)">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>
</body>
</html>
